starting work on AccomodationProperty
query path guards: [Ident { ident: "role", span: #0 bytes(1286..1290) }, Dot, Ident { ident: "authority", span: #0 bytes(1291..1300) }]
join statements ".left_join(AccomodationPropertyPhoto :: get_table_ref()).left_join(Addres :: get_table_ref()).left_join(Currency :: get_table_ref()).left_join(AccomodationPropertyToFacility ::\nget_table_ref().left_join(AccomodationPropertyFacility :: get_table_ref())).left_join(Language :: get_table_ref()).left_join(Role :: get_table_ref()).left_join(Room :: get_table_ref()).left_join(AccomodationPropertyStatu :: get_table_ref()).left_join(AccomodationPropertyToType ::\nget_table_ref().left_join(AccomodationPropertyType :: get_table_ref()))"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: accomodation_property)] pub struct
NewAccomodationProperty
{
    pub version : i64, pub stars : i32, pub currency_id : Option < i64 >, pub
    number_of_rooms : i32, pub hotel_logo : Option < String >, pub address_id
    : Option < i64 >, pub checked_out : Option < bool >, pub role_id : Option
    < i64 >, pub name : String, pub status_id : Option < i64 >, pub
    preferred_language_id : Option < i64 >
} #[derive(Serialize, Clone)] pub struct AccomodationPropertyWithAll
{
    #[serde(flatten)] pub self_data : AccomodationProperty, pub facilities :
    Vec < AccomodationPropertyFacility >, pub types : Vec <
    AccomodationPropertyType >, pub accomodation_property_photos : Vec <
    AccomodationPropertyPhoto >, pub rooms : Vec < Room >, pub currency :
    Option < Currency >, pub address : Option < Addres >, pub role : Option <
    Role >, pub status : Option < AccomodationPropertyStatu >, pub
    preferred_language : Option < Language >,
} impl AccomodationPropertyWithAll
{
    pub fn
    new_builder((self_data, facilities, types, accomodation_property_photos,
    rooms, currency, address, role, status, preferred_language) :
    (AccomodationProperty, Option < AccomodationPropertyFacility >, Option <
    AccomodationPropertyType >, Option < AccomodationPropertyPhoto >, Option <
    Room >, Option < Currency >, Option < Addres >, Option < Role >, Option <
    AccomodationPropertyStatu >, Option < Language >)) -> Self
    {
        Self
        {
            self_data, facilities : if let Some(data) = facilities
            { vec! [data] } else { Vec :: new() }, types : if let Some(data) =
            types { vec! [data] } else { Vec :: new() },
            accomodation_property_photos : if let Some(data) =
            accomodation_property_photos { vec! [data] } else
            { Vec :: new() }, rooms : if let Some(data) = rooms
            { vec! [data] } else { Vec :: new() }, currency, address, role,
            status, preferred_language,
        }
    } pub fn
    insert_data(& mut self,
    (self_data, facilities, types, accomodation_property_photos, rooms,
    currency, address, role, status, preferred_language) :
    (AccomodationProperty, Option < AccomodationPropertyFacility >, Option <
    AccomodationPropertyType >, Option < AccomodationPropertyPhoto >, Option <
    Room >, Option < Currency >, Option < Addres >, Option < Role >, Option <
    AccomodationPropertyStatu >, Option < Language >))
    {
        if let Some(data) = facilities { self.facilities.push(data) ; } if let
        Some(data) = types { self.types.push(data) ; } if let Some(data) =
        accomodation_property_photos
        { self.accomodation_property_photos.push(data) ; } if let Some(data) =
        rooms { self.rooms.push(data) ; }
    }
} impl AccomodationProperty
{
    pub fn get_table_ref() -> crate :: schema :: accomodation_property ::
    table { return crate :: schema :: accomodation_property :: table ; } pub
    fn find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: accomodation_property ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn
    insert(data : NewAccomodationProperty, conn : & mut MysqlConnection,) ->
    Result < NewAccomodationProperty, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: accomodation_property ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: accomodation_property ::
        table.filter(crate :: schema :: accomodation_property ::
        id.eq(uid)).first :: < Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    AccomodationPropertyWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec <
        AccomodationPropertyWithAll > = Vec :: new() ; let mut last_id = 0 ;
        let all_rows = crate :: schema :: accomodation_property ::
        table.left_join(AccomodationPropertyPhoto ::
        get_table_ref()).left_join(Addres ::
        get_table_ref()).left_join(Currency ::
        get_table_ref()).left_join(AccomodationPropertyToFacility ::
        get_table_ref().left_join(AccomodationPropertyFacility ::
        get_table_ref())).left_join(Language ::
        get_table_ref()).left_join(Role ::
        get_table_ref()).left_join(Room ::
        get_table_ref()).left_join(AccomodationPropertyStatu ::
        get_table_ref()).left_join(AccomodationPropertyToType ::
        get_table_ref().left_join(AccomodationPropertyType ::
        get_table_ref())).select((AccomodationProperty :: as_select(), Option
        :: < AccomodationPropertyFacility > :: as_select(), Option :: <
        AccomodationPropertyType > :: as_select(), Option :: <
        AccomodationPropertyPhoto > :: as_select(), Option :: < Room > ::
        as_select(), Option :: < Currency > :: as_select(), Option :: < Addres
        > :: as_select(), Option :: < Role > :: as_select(), Option :: <
        AccomodationPropertyStatu > :: as_select(), Option :: < Language > ::
        as_select())).load :: <
        (AccomodationProperty, Option :: < AccomodationPropertyFacility >,
        Option :: < AccomodationPropertyType >, Option :: <
        AccomodationPropertyPhoto >, Option :: < Room >, Option :: < Currency
        >, Option :: < Addres >, Option :: < Role >, Option :: <
        AccomodationPropertyStatu >, Option :: < Language >) > (conn) ? ; for
        query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = AccomodationPropertyWithAll ::
                new_builder(query_row) ; ret_data.push(data) ; last_id =
                current_id ;
            }
        } Ok(ret_data)
    } pub fn get_facilities(& self, conn : & mut MysqlConnection) -> Vec <
    AccomodationPropertyFacility >
    {
        return AccomodationPropertyToFacility ::
        belonging_to(&
        self).inner_join(AccomodationPropertyFacility ::
        get_table_ref()).select(AccomodationPropertyFacility ::
        as_select()).load(conn).expect("error running query to fetch many to many relationship")
        ;
    } pub fn get_types(& self, conn : & mut MysqlConnection) -> Vec <
    AccomodationPropertyType >
    {
        return AccomodationPropertyToType ::
        belonging_to(&
        self).inner_join(AccomodationPropertyType ::
        get_table_ref()).select(AccomodationPropertyType ::
        as_select()).load(conn).expect("error running query to fetch many to many relationship")
        ;
    } pub fn
    get_accomodation_property_photos(& self, conn : & mut MysqlConnection) ->
    Vec < AccomodationPropertyPhoto >
    {
        return AccomodationPropertyPhoto ::
        belonging_to(&
        self).select(AccomodationPropertyPhoto ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn get_rooms(& self, conn : & mut MysqlConnection) -> Vec < Room >
    {
        return Room ::
        belonging_to(&
        self).select(Room ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn get_currency(& self, conn : & mut MysqlConnection) -> Option <
    Currency >
    {
        if let Some(fk_value) = self.currency_id
        {
            return Currency ::
            find(fk_value, conn).expect("could not fetch relation") ;
        } else { return None ; }
    } pub fn get_address(& self, conn : & mut MysqlConnection) -> Option <
    Addres >
    {
        if let Some(fk_value) = self.address_id
        {
            return Addres ::
            find(fk_value, conn).expect("could not fetch relation") ;
        } else { return None ; }
    } pub fn get_role(& self, conn : & mut MysqlConnection) -> Option < Role >
    {
        if let Some(fk_value) = self.role_id
        {
            return Role ::
            find(fk_value, conn).expect("could not fetch relation") ;
        } else { return None ; }
    } pub fn get_status(& self, conn : & mut MysqlConnection) -> Option <
    AccomodationPropertyStatu >
    {
        if let Some(fk_value) = self.status_id
        {
            return AccomodationPropertyStatu ::
            find(fk_value, conn).expect("could not fetch relation") ;
        } else { return None ; }
    } pub fn get_preferred_language(& self, conn : & mut MysqlConnection) ->
    Option < Language >
    {
        if let Some(fk_value) = self.preferred_language_id
        {
            return Language ::
            find(fk_value, conn).expect("could not fetch relation") ;
        } else { return None ; }
    } pub fn
    find_all_with_accomodation_property_photos(conn : & mut MysqlConnection)
    -> Result < Vec < AccomodationPropertyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AccomodationPropertyLazy > = Vec :: new() ;
        let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property ::
        table.left_join(AccomodationPropertyPhoto ::
        get_table_ref()).select((AccomodationProperty :: as_select(), Option
        :: < AccomodationPropertyPhoto > :: as_select())).load :: <
        (AccomodationProperty, Option :: < AccomodationPropertyPhoto >) >
        (conn) ? ; for(self_data, accomodation_property_photos) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = accomodation_property_photos
                { data.push_or_set_accomodation_property_photos(val) ; }
            } else
            {
                let mut data = AccomodationPropertyLazy :: init(self_data) ;
                if let Some(val) = accomodation_property_photos
                { data.push_or_set_accomodation_property_photos(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_address(conn : & mut MysqlConnection) -> Result <
    Vec < AccomodationPropertyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AccomodationPropertyLazy > = Vec :: new() ;
        let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property ::
        table.left_join(Addres ::
        get_table_ref()).select((AccomodationProperty :: as_select(), Option
        :: < Addres > :: as_select())).load :: <
        (AccomodationProperty, Option :: < Addres >) > (conn) ? ;
        for(self_data, address) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = address { data.push_or_set_address(val) ; }
            } else
            {
                let mut data = AccomodationPropertyLazy :: init(self_data) ;
                if let Some(val) = address { data.push_or_set_address(val) ; }
                ; ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_currency(conn : & mut MysqlConnection) -> Result <
    Vec < AccomodationPropertyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AccomodationPropertyLazy > = Vec :: new() ;
        let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property ::
        table.left_join(Currency ::
        get_table_ref()).select((AccomodationProperty :: as_select(), Option
        :: < Currency > :: as_select())).load :: <
        (AccomodationProperty, Option :: < Currency >) > (conn) ? ;
        for(self_data, currency) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = currency { data.push_or_set_currency(val) ; }
            } else
            {
                let mut data = AccomodationPropertyLazy :: init(self_data) ;
                if let Some(val) = currency
                { data.push_or_set_currency(val) ; } ; ret_data.push(data) ;
                last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_facilities(conn : & mut MysqlConnection) -> Result
    < Vec < AccomodationPropertyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AccomodationPropertyLazy > = Vec :: new() ;
        let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property ::
        table.left_join(AccomodationPropertyToFacility ::
        get_table_ref().left_join(AccomodationPropertyFacility ::
        get_table_ref())).select((AccomodationProperty :: as_select(), Option
        :: < AccomodationPropertyFacility > :: as_select())).load :: <
        (AccomodationProperty, Option :: < AccomodationPropertyFacility >) >
        (conn) ? ; for(self_data, facilities) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = facilities { data.push_or_set_facilities(val) ; }
            } else
            {
                let mut data = AccomodationPropertyLazy :: init(self_data) ;
                if let Some(val) = facilities
                { data.push_or_set_facilities(val) ; } ; ret_data.push(data) ;
                last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_preferred_language(conn : & mut MysqlConnection) ->
    Result < Vec < AccomodationPropertyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AccomodationPropertyLazy > = Vec :: new() ;
        let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property ::
        table.left_join(Language ::
        get_table_ref()).select((AccomodationProperty :: as_select(), Option
        :: < Language > :: as_select())).load :: <
        (AccomodationProperty, Option :: < Language >) > (conn) ? ;
        for(self_data, preferred_language) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = preferred_language
                { data.push_or_set_preferred_language(val) ; }
            } else
            {
                let mut data = AccomodationPropertyLazy :: init(self_data) ;
                if let Some(val) = preferred_language
                { data.push_or_set_preferred_language(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_role(conn : & mut MysqlConnection) -> Result < Vec
    < AccomodationPropertyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AccomodationPropertyLazy > = Vec :: new() ;
        let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property ::
        table.left_join(Role ::
        get_table_ref()).select((AccomodationProperty :: as_select(), Option
        :: < Role > :: as_select())).load :: <
        (AccomodationProperty, Option :: < Role >) > (conn) ? ;
        for(self_data, role) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = role { data.push_or_set_role(val) ; }
            } else
            {
                let mut data = AccomodationPropertyLazy :: init(self_data) ;
                if let Some(val) = role { data.push_or_set_role(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_rooms(conn : & mut MysqlConnection) -> Result < Vec
    < AccomodationPropertyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AccomodationPropertyLazy > = Vec :: new() ;
        let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property ::
        table.left_join(Room ::
        get_table_ref()).select((AccomodationProperty :: as_select(), Option
        :: < Room > :: as_select())).load :: <
        (AccomodationProperty, Option :: < Room >) > (conn) ? ;
        for(self_data, rooms) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = rooms { data.push_or_set_rooms(val) ; }
            } else
            {
                let mut data = AccomodationPropertyLazy :: init(self_data) ;
                if let Some(val) = rooms { data.push_or_set_rooms(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_status(conn : & mut MysqlConnection) -> Result <
    Vec < AccomodationPropertyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AccomodationPropertyLazy > = Vec :: new() ;
        let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property ::
        table.left_join(AccomodationPropertyStatu ::
        get_table_ref()).select((AccomodationProperty :: as_select(), Option
        :: < AccomodationPropertyStatu > :: as_select())).load :: <
        (AccomodationProperty, Option :: < AccomodationPropertyStatu >) >
        (conn) ? ; for(self_data, status) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = status { data.push_or_set_status(val) ; }
            } else
            {
                let mut data = AccomodationPropertyLazy :: init(self_data) ;
                if let Some(val) = status { data.push_or_set_status(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_types(conn : & mut MysqlConnection) -> Result < Vec
    < AccomodationPropertyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AccomodationPropertyLazy > = Vec :: new() ;
        let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property ::
        table.left_join(AccomodationPropertyToType ::
        get_table_ref().left_join(AccomodationPropertyType ::
        get_table_ref())).select((AccomodationProperty :: as_select(), Option
        :: < AccomodationPropertyType > :: as_select())).load :: <
        (AccomodationProperty, Option :: < AccomodationPropertyType >) >
        (conn) ? ; for(self_data, types) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = types { data.push_or_set_types(val) ; }
            } else
            {
                let mut data = AccomodationPropertyLazy :: init(self_data) ;
                if let Some(val) = types { data.push_or_set_types(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct AccomodationPropertyLazy
{
    #[serde(flatten)] pub self_data : AccomodationProperty, pub facilities :
    Option < Vec < AccomodationPropertyFacility > >, pub types : Option < Vec
    < AccomodationPropertyType > >, pub accomodation_property_photos : Option
    < Vec < AccomodationPropertyPhoto > >, pub rooms : Option < Vec < Room >
    >, pub currency : Option < Currency >, pub address : Option < Addres >,
    pub role : Option < Role >, pub status : Option <
    AccomodationPropertyStatu >, pub preferred_language : Option < Language >
} impl AccomodationPropertyLazy
{
    pub fn init(self_data : AccomodationProperty) -> Self
    {
        Self
        {
            self_data, facilities : None, types : None,
            accomodation_property_photos : None, rooms : None, currency :
            None, address : None, role : None, status : None,
            preferred_language : None
        }
    } pub fn
    push_or_set_accomodation_property_photos(& mut self, val :
    AccomodationPropertyPhoto)
    {
        if let Some(vec) = self.accomodation_property_photos.as_mut()
        { vec.push(val) ; } else
        { self.accomodation_property_photos = Some(vec! [val]) ; }
    } pub fn push_or_set_address(& mut self, val : Addres)
    { self.address = Some(val) ; } pub fn
    push_or_set_currency(& mut self, val : Currency)
    { self.currency = Some(val) ; } pub fn
    push_or_set_facilities(& mut self, val : AccomodationPropertyFacility)
    {
        if let Some(vec) = self.facilities.as_mut() { vec.push(val) ; } else
        { self.facilities = Some(vec! [val]) ; }
    } pub fn push_or_set_preferred_language(& mut self, val : Language)
    { self.preferred_language = Some(val) ; } pub fn
    push_or_set_role(& mut self, val : Role) { self.role = Some(val) ; } pub
    fn push_or_set_rooms(& mut self, val : Room)
    {
        if let Some(vec) = self.rooms.as_mut() { vec.push(val) ; } else
        { self.rooms = Some(vec! [val]) ; }
    } pub fn push_or_set_status(& mut self, val : AccomodationPropertyStatu)
    { self.status = Some(val) ; } pub fn
    push_or_set_types(& mut self, val : AccomodationPropertyType)
    {
        if let Some(vec) = self.types.as_mut() { vec.push(val) ; } else
        { self.types = Some(vec! [val]) ; }
    }
}
starting work on AccomodationPropertyFacility
join statements ".left_join(AccomodationPropertyToFacility :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: accomodation_property_facility)] pub
struct NewAccomodationPropertyFacility
{
    pub version : i64, pub name : String, pub hac : Option < String >, pub
    booking_extended_code : Option < String >
} #[derive(Serialize, Clone)] pub struct AccomodationPropertyFacilityWithAll
{
    #[serde(flatten)] pub self_data : AccomodationPropertyFacility, pub
    join_property : Vec < AccomodationPropertyToFacility >,
} impl AccomodationPropertyFacilityWithAll
{
    pub fn
    new_builder((self_data, join_property) :
    (AccomodationPropertyFacility, Option < AccomodationPropertyToFacility >))
    -> Self
    {
        Self
        {
            self_data, join_property : if let Some(data) = join_property
            { vec! [data] } else { Vec :: new() },
        }
    } pub fn
    insert_data(& mut self, (self_data, join_property) :
    (AccomodationPropertyFacility, Option < AccomodationPropertyToFacility >))
    { if let Some(data) = join_property { self.join_property.push(data) ; } }
} impl AccomodationPropertyFacility
{
    pub fn get_table_ref() -> crate :: schema ::
    accomodation_property_facility :: table
    { return crate :: schema :: accomodation_property_facility :: table ; }
    pub fn find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: accomodation_property_facility ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn
    insert(data : NewAccomodationPropertyFacility, conn : & mut
    MysqlConnection,) -> Result < NewAccomodationPropertyFacility, diesel ::
    result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: accomodation_property_facility ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: accomodation_property_facility ::
        table.filter(crate :: schema :: accomodation_property_facility ::
        id.eq(uid)).first :: < Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    AccomodationPropertyFacilityWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec <
        AccomodationPropertyFacilityWithAll > = Vec :: new() ; let mut last_id
        = 0 ; let all_rows = crate :: schema :: accomodation_property_facility
        ::
        table.left_join(AccomodationPropertyToFacility ::
        get_table_ref()).select((AccomodationPropertyFacility :: as_select(),
        Option :: < AccomodationPropertyToFacility > :: as_select())).load ::
        <
        (AccomodationPropertyFacility, Option :: <
        AccomodationPropertyToFacility >) > (conn) ? ; for query_row in
        all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = AccomodationPropertyFacilityWithAll ::
                new_builder(query_row) ; ret_data.push(data) ; last_id =
                current_id ;
            }
        } Ok(ret_data)
    } pub fn get_join_property(& self, conn : & mut MysqlConnection) -> Vec <
    AccomodationPropertyToFacility >
    {
        return AccomodationPropertyToFacility ::
        belonging_to(&
        self).select(AccomodationPropertyToFacility ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn find_all_with_join_property(conn : & mut MysqlConnection) ->
    Result < Vec < AccomodationPropertyFacilityLazy >, diesel :: result ::
    Error >
    {
        let mut ret_data : Vec < AccomodationPropertyFacilityLazy > = Vec ::
        new() ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property_facility ::
        table.left_join(AccomodationPropertyToFacility ::
        get_table_ref()).select((AccomodationPropertyFacility :: as_select(),
        Option :: < AccomodationPropertyToFacility > :: as_select())).load ::
        <
        (AccomodationPropertyFacility, Option :: <
        AccomodationPropertyToFacility >) > (conn) ? ;
        for(self_data, join_property) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = join_property
                {
                    data.push_or_set_join_property(val.get_for_accomodation_property_facility_id())
                    ;
                }
            } else
            {
                let mut data = AccomodationPropertyFacilityLazy ::
                init(self_data) ; if let Some(val) = join_property
                {
                    data.push_or_set_join_property(val.get_for_accomodation_property_facility_id())
                    ;
                } ; ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct AccomodationPropertyFacilityLazy
{
    #[serde(flatten)] pub self_data : AccomodationPropertyFacility, pub
    join_property : Option < Vec < i64 > >
} impl AccomodationPropertyFacilityLazy
{
    pub fn init(self_data : AccomodationPropertyFacility) -> Self
    { Self { self_data, join_property : None } } pub fn
    push_or_set_join_property(& mut self, val : i64)
    {
        if let Some(vec) = self.join_property.as_mut() { vec.push(val) ; }
        else { self.join_property = Some(vec! [val]) ; }
    }
}
starting work on AccomodationPropertyPhoto
join statements ".inner_join(AccomodationProperty :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: accomodation_property_photo)] pub
struct NewAccomodationPropertyPhoto
{
    pub version : i64, pub accomodation_property_id : i64, pub file_name :
    String
} #[derive(Serialize, Clone)] pub struct AccomodationPropertyPhotoWithAll
{
    #[serde(flatten)] pub self_data : AccomodationPropertyPhoto, pub
    accomodation_property : AccomodationProperty,
} impl AccomodationPropertyPhotoWithAll
{
    pub fn
    new_builder((self_data, accomodation_property) :
    (AccomodationPropertyPhoto, AccomodationProperty)) -> Self
    { Self { self_data, accomodation_property, } } pub fn
    insert_data(& mut self, (self_data, accomodation_property) :
    (AccomodationPropertyPhoto, AccomodationProperty)) {}
} impl AccomodationPropertyPhoto
{
    pub fn get_table_ref() -> crate :: schema :: accomodation_property_photo
    :: table
    { return crate :: schema :: accomodation_property_photo :: table ; } pub
    fn find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: accomodation_property_photo ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn
    insert(data : NewAccomodationPropertyPhoto, conn : & mut MysqlConnection,)
    -> Result < NewAccomodationPropertyPhoto, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: accomodation_property_photo ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: accomodation_property_photo ::
        table.filter(crate :: schema :: accomodation_property_photo ::
        id.eq(uid)).first :: < Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    AccomodationPropertyPhotoWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec <
        AccomodationPropertyPhotoWithAll > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: accomodation_property_photo ::
        table.inner_join(AccomodationProperty ::
        get_table_ref()).select((AccomodationPropertyPhoto :: as_select(),
        AccomodationProperty :: as_select())).load :: <
        (AccomodationPropertyPhoto, AccomodationProperty) > (conn) ? ; for
        query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = AccomodationPropertyPhotoWithAll ::
                new_builder(query_row) ; ret_data.push(data) ; last_id =
                current_id ;
            }
        } Ok(ret_data)
    } pub fn get_accomodation_property(& self, conn : & mut MysqlConnection)
    -> AccomodationProperty
    {
        return AccomodationProperty ::
        find(self.accomodation_property_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    } pub fn find_all_with_accomodation_property(conn : & mut MysqlConnection)
    -> Result < Vec < AccomodationPropertyPhotoLazy >, diesel :: result ::
    Error >
    {
        let mut ret_data : Vec < AccomodationPropertyPhotoLazy > = Vec ::
        new() ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property_photo ::
        table.inner_join(AccomodationProperty ::
        get_table_ref()).select((AccomodationPropertyPhoto :: as_select(),
        AccomodationProperty :: as_select())).load :: <
        (AccomodationPropertyPhoto, AccomodationProperty) > (conn) ? ;
        for(self_data, accomodation_property) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ;
                data.push_or_set_accomodation_property(accomodation_property)
                ;
            } else
            {
                let mut data = AccomodationPropertyPhotoLazy ::
                init(self_data) ;
                data.push_or_set_accomodation_property(accomodation_property)
                ; ; ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct AccomodationPropertyPhotoLazy
{
    #[serde(flatten)] pub self_data : AccomodationPropertyPhoto, pub
    accomodation_property : Option < AccomodationProperty >
} impl AccomodationPropertyPhotoLazy
{
    pub fn init(self_data : AccomodationPropertyPhoto) -> Self
    { Self { self_data, accomodation_property : None } } pub fn
    push_or_set_accomodation_property(& mut self, val : AccomodationProperty)
    { self.accomodation_property = Some(val) ; }
}
starting work on AccomodationPropertyStatu
join statements ".left_join(AccomodationProperty :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: accomodation_property_status)] pub
struct NewAccomodationPropertyStatu { pub version : i64, pub status : String }
#[derive(Serialize, Clone)] pub struct AccomodationPropertyStatuWithAll
{
    #[serde(flatten)] pub self_data : AccomodationPropertyStatu, pub
    accomodation_properties : Vec < AccomodationProperty >,
} impl AccomodationPropertyStatuWithAll
{
    pub fn
    new_builder((self_data, accomodation_properties) :
    (AccomodationPropertyStatu, Option < AccomodationProperty >)) -> Self
    {
        Self
        {
            self_data, accomodation_properties : if let Some(data) =
            accomodation_properties { vec! [data] } else { Vec :: new() },
        }
    } pub fn
    insert_data(& mut self, (self_data, accomodation_properties) :
    (AccomodationPropertyStatu, Option < AccomodationProperty >))
    {
        if let Some(data) = accomodation_properties
        { self.accomodation_properties.push(data) ; }
    }
} impl AccomodationPropertyStatu
{
    pub fn get_table_ref() -> crate :: schema :: accomodation_property_status
    :: table
    { return crate :: schema :: accomodation_property_status :: table ; } pub
    fn find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: accomodation_property_status ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn
    insert(data : NewAccomodationPropertyStatu, conn : & mut MysqlConnection,)
    -> Result < NewAccomodationPropertyStatu, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: accomodation_property_status ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: accomodation_property_status ::
        table.filter(crate :: schema :: accomodation_property_status ::
        id.eq(uid)).first :: < Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    AccomodationPropertyStatuWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec <
        AccomodationPropertyStatuWithAll > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: accomodation_property_status ::
        table.left_join(AccomodationProperty ::
        get_table_ref()).select((AccomodationPropertyStatu :: as_select(),
        Option :: < AccomodationProperty > :: as_select())).load :: <
        (AccomodationPropertyStatu, Option :: < AccomodationProperty >) >
        (conn) ? ; for query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = AccomodationPropertyStatuWithAll ::
                new_builder(query_row) ; ret_data.push(data) ; last_id =
                current_id ;
            }
        } Ok(ret_data)
    } pub fn get_accomodation_properties(& self, conn : & mut MysqlConnection)
    -> Vec < AccomodationProperty >
    {
        return AccomodationProperty ::
        belonging_to(&
        self).select(AccomodationProperty ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn
    find_all_with_accomodation_properties(conn : & mut MysqlConnection) ->
    Result < Vec < AccomodationPropertyStatuLazy >, diesel :: result :: Error
    >
    {
        let mut ret_data : Vec < AccomodationPropertyStatuLazy > = Vec ::
        new() ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property_status ::
        table.left_join(AccomodationProperty ::
        get_table_ref()).select((AccomodationPropertyStatu :: as_select(),
        Option :: < AccomodationProperty > :: as_select())).load :: <
        (AccomodationPropertyStatu, Option :: < AccomodationProperty >) >
        (conn) ? ; for(self_data, accomodation_properties) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = accomodation_properties
                { data.push_or_set_accomodation_properties(val) ; }
            } else
            {
                let mut data = AccomodationPropertyStatuLazy ::
                init(self_data) ; if let Some(val) = accomodation_properties
                { data.push_or_set_accomodation_properties(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct AccomodationPropertyStatuLazy
{
    #[serde(flatten)] pub self_data : AccomodationPropertyStatu, pub
    accomodation_properties : Option < Vec < AccomodationProperty > >
} impl AccomodationPropertyStatuLazy
{
    pub fn init(self_data : AccomodationPropertyStatu) -> Self
    { Self { self_data, accomodation_properties : None } } pub fn
    push_or_set_accomodation_properties(& mut self, val :
    AccomodationProperty)
    {
        if let Some(vec) = self.accomodation_properties.as_mut()
        { vec.push(val) ; } else
        { self.accomodation_properties = Some(vec! [val]) ; }
    }
}
starting work on AccomodationPropertyToFacility
join statements ""
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: accomodation_property_to_facility)]
pub struct NewAccomodationPropertyToFacility
{
    pub accomodation_property_id : i64, pub accomodation_property_facility_id
    : i64
} impl AccomodationPropertyToFacility
{
    pub fn get_table_ref() -> crate :: schema ::
    accomodation_property_to_facility :: table
    { return crate :: schema :: accomodation_property_to_facility :: table ; }
    pub fn find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: accomodation_property_to_facility ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn
    insert(data : NewAccomodationPropertyToFacility, conn : & mut
    MysqlConnection,) -> Result < NewAccomodationPropertyToFacility, diesel ::
    result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: accomodation_property_to_facility ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn
    find(accomodation_property_facility_id : i64, accomodation_property_id :
    i64, conn : & mut MysqlConnection,) -> Result < Option < Self >, diesel ::
    result :: Error >
    {
        let result = crate :: schema :: accomodation_property_to_facility ::
        table.filter(crate :: schema :: accomodation_property_to_facility ::
        accomodation_property_facility_id.eq(accomodation_property_facility_id)).filter(crate
        :: schema :: accomodation_property_to_facility ::
        accomodation_property_id.eq(accomodation_property_id)).first :: < Self
        > (conn).optional() ? ; Ok(result)
    }
} impl AccomodationPropertyToFacility
{
    pub fn get_for_accomodation_property_id(& self) -> i64
    { self.accomodation_property_facility_id } pub fn
    get_for_accomodation_property_facility_id(& self) -> i64
    { self.accomodation_property_id }
}
starting work on AccomodationPropertyToLanguage
join statements ""
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: accomodation_property_to_language)]
pub struct NewAccomodationPropertyToLanguage
{ pub accomodation_property_id : i64, pub language_id : i64 } impl
AccomodationPropertyToLanguage
{
    pub fn get_table_ref() -> crate :: schema ::
    accomodation_property_to_language :: table
    { return crate :: schema :: accomodation_property_to_language :: table ; }
    pub fn find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: accomodation_property_to_language ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn
    insert(data : NewAccomodationPropertyToLanguage, conn : & mut
    MysqlConnection,) -> Result < NewAccomodationPropertyToLanguage, diesel ::
    result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: accomodation_property_to_language ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn
    find(accomodation_property_id : i64, language_id : i64, conn : & mut
    MysqlConnection,) -> Result < Option < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: accomodation_property_to_language ::
        table.filter(crate :: schema :: accomodation_property_to_language ::
        accomodation_property_id.eq(accomodation_property_id)).filter(crate ::
        schema :: accomodation_property_to_language ::
        language_id.eq(language_id)).first :: < Self > (conn).optional() ? ;
        Ok(result)
    }
} impl AccomodationPropertyToLanguage
{
    pub fn get_for_accomodation_property_id(& self) -> i64
    { self.language_id } pub fn get_for_language_id(& self) -> i64
    { self.accomodation_property_id }
}
starting work on AccomodationPropertyToType
join statements ""
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: accomodation_property_to_type)] pub
struct NewAccomodationPropertyToType
{
    pub accomodation_property_id : i64, pub accomodation_property_type_id :
    i64
} impl AccomodationPropertyToType
{
    pub fn get_table_ref() -> crate :: schema :: accomodation_property_to_type
    :: table
    { return crate :: schema :: accomodation_property_to_type :: table ; } pub
    fn find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: accomodation_property_to_type ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn
    insert(data : NewAccomodationPropertyToType, conn : & mut
    MysqlConnection,) -> Result < NewAccomodationPropertyToType, diesel ::
    result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: accomodation_property_to_type ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn
    find(accomodation_property_id : i64, accomodation_property_type_id : i64,
    conn : & mut MysqlConnection,) -> Result < Option < Self >, diesel ::
    result :: Error >
    {
        let result = crate :: schema :: accomodation_property_to_type ::
        table.filter(crate :: schema :: accomodation_property_to_type ::
        accomodation_property_id.eq(accomodation_property_id)).filter(crate ::
        schema :: accomodation_property_to_type ::
        accomodation_property_type_id.eq(accomodation_property_type_id)).first
        :: < Self > (conn).optional() ? ; Ok(result)
    }
} impl AccomodationPropertyToType
{
    pub fn get_for_accomodation_property_id(& self) -> i64
    { self.accomodation_property_type_id } pub fn
    get_for_accomodation_property_type_id(& self) -> i64
    { self.accomodation_property_id }
}
starting work on AccomodationPropertyType
join statements ""
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: accomodation_property_type)] pub
struct NewAccomodationPropertyType { pub version : i64, pub type_ : String }
impl AccomodationPropertyType
{
    pub fn get_table_ref() -> crate :: schema :: accomodation_property_type ::
    table { return crate :: schema :: accomodation_property_type :: table ; }
    pub fn find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: accomodation_property_type ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn
    insert(data : NewAccomodationPropertyType, conn : & mut MysqlConnection,)
    -> Result < NewAccomodationPropertyType, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: accomodation_property_type ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: accomodation_property_type ::
        table.filter(crate :: schema :: accomodation_property_type ::
        id.eq(uid)).first :: < Self > (conn).optional() ? ; Ok(result)
    }
}
starting work on Addres
join statements ".inner_join(City :: get_table_ref()).left_join(AccomodationProperty :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: address)] pub struct NewAddres
{
    pub version : i64, pub region : Option < String >, pub telephone : Option
    < String >, pub fax : Option < String >, pub additional_emails : Option <
    String >, pub location : Option < String >, pub city : String, pub on_map
    : Option < String >, pub street : String, pub zip_code : Option < String
    >, pub email : Option < String >, pub website : Option < String >, pub
    _city_id : i64
} #[derive(Serialize, Clone)] pub struct AddresWithAll
{
    #[serde(flatten)] pub self_data : Addres, pub accomodation_properties :
    Vec < AccomodationProperty >, pub _city : City,
} impl AddresWithAll
{
    pub fn
    new_builder((self_data, accomodation_properties, _city) :
    (Addres, Option < AccomodationProperty >, City)) -> Self
    {
        Self
        {
            self_data, accomodation_properties : if let Some(data) =
            accomodation_properties { vec! [data] } else { Vec :: new() },
            _city,
        }
    } pub fn
    insert_data(& mut self, (self_data, accomodation_properties, _city) :
    (Addres, Option < AccomodationProperty >, City))
    {
        if let Some(data) = accomodation_properties
        { self.accomodation_properties.push(data) ; }
    }
} impl Addres
{
    pub fn get_table_ref() -> crate :: schema :: address :: table
    { return crate :: schema :: address :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: address ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewAddres, conn : & mut MysqlConnection,) -> Result
    < NewAddres, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: address ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: address ::
        table.filter(crate :: schema :: address :: id.eq(uid)).first :: < Self
        > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    AddresWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < AddresWithAll > =
        Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        address ::
        table.inner_join(City ::
        get_table_ref()).left_join(AccomodationProperty ::
        get_table_ref()).select((Addres :: as_select(), Option :: <
        AccomodationProperty > :: as_select(), City :: as_select())).load :: <
        (Addres, Option :: < AccomodationProperty >, City) > (conn) ? ; for
        query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = AddresWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_accomodation_properties(& self, conn : & mut MysqlConnection)
    -> Vec < AccomodationProperty >
    {
        return AccomodationProperty ::
        belonging_to(&
        self).select(AccomodationProperty ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn get__city(& self, conn : & mut MysqlConnection) -> City
    {
        return City ::
        find(self._city_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    } pub fn find_all_with__city(conn : & mut MysqlConnection) -> Result < Vec
    < AddresLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AddresLazy > = Vec :: new() ; let mut last_id
        = 0 ; let all_rows = crate :: schema :: address ::
        table.inner_join(City ::
        get_table_ref()).select((Addres :: as_select(), City ::
        as_select())).load :: < (Addres, City) > (conn) ? ;
        for(self_data, _city) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ;
                data.push_or_set__city(_city) ;
            } else
            {
                let mut data = AddresLazy :: init(self_data) ;
                data.push_or_set__city(_city) ; ; ret_data.push(data) ;
                last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn
    find_all_with_accomodation_properties(conn : & mut MysqlConnection) ->
    Result < Vec < AddresLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AddresLazy > = Vec :: new() ; let mut last_id
        = 0 ; let all_rows = crate :: schema :: address ::
        table.left_join(AccomodationProperty ::
        get_table_ref()).select((Addres :: as_select(), Option :: <
        AccomodationProperty > :: as_select())).load :: <
        (Addres, Option :: < AccomodationProperty >) > (conn) ? ;
        for(self_data, accomodation_properties) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = accomodation_properties
                { data.push_or_set_accomodation_properties(val) ; }
            } else
            {
                let mut data = AddresLazy :: init(self_data) ; if let
                Some(val) = accomodation_properties
                { data.push_or_set_accomodation_properties(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct AddresLazy
{
    #[serde(flatten)] pub self_data : Addres, pub accomodation_properties :
    Option < Vec < AccomodationProperty > >, pub _city : Option < City >
} impl AddresLazy
{
    pub fn init(self_data : Addres) -> Self
    { Self { self_data, accomodation_properties : None, _city : None } } pub
    fn push_or_set__city(& mut self, val : City) { self._city = Some(val) ; }
    pub fn
    push_or_set_accomodation_properties(& mut self, val :
    AccomodationProperty)
    {
        if let Some(vec) = self.accomodation_properties.as_mut()
        { vec.push(val) ; } else
        { self.accomodation_properties = Some(vec! [val]) ; }
    }
}
starting work on City
join statements ".left_join(Addres :: get_table_ref()).inner_join(County :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: city)] pub struct NewCity
{
    pub cc_fips : Option < String >, pub country_iso_id : Option < String >,
    pub full_name : Option < String >, pub version : i64, pub show_city :
    bool, pub county_id : i64
} #[derive(Serialize, Clone)] pub struct CityWithAll
{
    #[serde(flatten)] pub self_data : City, pub addresses : Vec < Addres >,
    pub county : County,
} impl CityWithAll
{
    pub fn
    new_builder((self_data, addresses, county) :
    (City, Option < Addres >, County)) -> Self
    {
        Self
        {
            self_data, addresses : if let Some(data) = addresses
            { vec! [data] } else { Vec :: new() }, county,
        }
    } pub fn
    insert_data(& mut self, (self_data, addresses, county) :
    (City, Option < Addres >, County))
    { if let Some(data) = addresses { self.addresses.push(data) ; } }
} impl City
{
    pub fn get_table_ref() -> crate :: schema :: city :: table
    { return crate :: schema :: city :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: city ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewCity, conn : & mut MysqlConnection,) -> Result <
    NewCity, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: city ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: city ::
        table.filter(crate :: schema :: city :: id.eq(uid)).first :: < Self >
        (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    CityWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < CityWithAll > =
        Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        city ::
        table.left_join(Addres ::
        get_table_ref()).inner_join(County ::
        get_table_ref()).select((City :: as_select(), Option :: < Addres > ::
        as_select(), County :: as_select())).load :: <
        (City, Option :: < Addres >, County) > (conn) ? ; for query_row in
        all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = CityWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_addresses(& self, conn : & mut MysqlConnection) -> Vec <
    Addres >
    {
        return Addres ::
        belonging_to(&
        self).select(Addres ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn get_county(& self, conn : & mut MysqlConnection) -> County
    {
        return County ::
        find(self.county_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    } pub fn find_all_with_addresses(conn : & mut MysqlConnection) -> Result <
    Vec < CityLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < CityLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: city ::
        table.left_join(Addres ::
        get_table_ref()).select((City :: as_select(), Option :: < Addres > ::
        as_select())).load :: < (City, Option :: < Addres >) > (conn) ? ;
        for(self_data, addresses) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = addresses { data.push_or_set_addresses(val) ; }
            } else
            {
                let mut data = CityLazy :: init(self_data) ; if let Some(val)
                = addresses { data.push_or_set_addresses(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_county(conn : & mut MysqlConnection) -> Result <
    Vec < CityLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < CityLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: city ::
        table.inner_join(County ::
        get_table_ref()).select((City :: as_select(), County ::
        as_select())).load :: < (City, County) > (conn) ? ;
        for(self_data, county) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ;
                data.push_or_set_county(county) ;
            } else
            {
                let mut data = CityLazy :: init(self_data) ;
                data.push_or_set_county(county) ; ; ret_data.push(data) ;
                last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct CityLazy
{
    #[serde(flatten)] pub self_data : City, pub addresses : Option < Vec <
    Addres > >, pub county : Option < County >
} impl CityLazy
{
    pub fn init(self_data : City) -> Self
    { Self { self_data, addresses : None, county : None } } pub fn
    push_or_set_addresses(& mut self, val : Addres)
    {
        if let Some(vec) = self.addresses.as_mut() { vec.push(val) ; } else
        { self.addresses = Some(vec! [val]) ; }
    } pub fn push_or_set_county(& mut self, val : County)
    { self.county = Some(val) ; }
}
starting work on Country
join statements ".left_join(County :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: country)] pub struct NewCountry
{
    pub id_fips : Option < String >, pub id_iso : Option < String >, pub tld :
    Option < String >, pub country_name : Option < String >, pub version : i64
} #[derive(Serialize, Clone)] pub struct CountryWithAll
{ #[serde(flatten)] pub self_data : Country, pub counties : Vec < County >, }
impl CountryWithAll
{
    pub fn new_builder((self_data, counties) : (Country, Option < County >))
    -> Self
    {
        Self
        {
            self_data, counties : if let Some(data) = counties { vec! [data] }
            else { Vec :: new() },
        }
    } pub fn
    insert_data(& mut self, (self_data, counties) :
    (Country, Option < County >))
    { if let Some(data) = counties { self.counties.push(data) ; } }
} impl Country
{
    pub fn get_table_ref() -> crate :: schema :: country :: table
    { return crate :: schema :: country :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: country ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewCountry, conn : & mut MysqlConnection,) ->
    Result < NewCountry, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: country ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: country ::
        table.filter(crate :: schema :: country :: id.eq(uid)).first :: < Self
        > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    CountryWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < CountryWithAll > =
        Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        country ::
        table.left_join(County ::
        get_table_ref()).select((Country :: as_select(), Option :: < County >
        :: as_select())).load :: < (Country, Option :: < County >) > (conn) ?
        ; for query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = CountryWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_counties(& self, conn : & mut MysqlConnection) -> Vec <
    County >
    {
        return County ::
        belonging_to(&
        self).select(County ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn find_all_with_counties(conn : & mut MysqlConnection) -> Result <
    Vec < CountryLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < CountryLazy > = Vec :: new() ; let mut
        last_id = 0 ; let all_rows = crate :: schema :: country ::
        table.left_join(County ::
        get_table_ref()).select((Country :: as_select(), Option :: < County >
        :: as_select())).load :: < (Country, Option :: < County >) > (conn) ?
        ; for(self_data, counties) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = counties { data.push_or_set_counties(val) ; }
            } else
            {
                let mut data = CountryLazy :: init(self_data) ; if let
                Some(val) = counties { data.push_or_set_counties(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct CountryLazy
{
    #[serde(flatten)] pub self_data : Country, pub counties : Option < Vec <
    County > >
} impl CountryLazy
{
    pub fn init(self_data : Country) -> Self
    { Self { self_data, counties : None } } pub fn
    push_or_set_counties(& mut self, val : County)
    {
        if let Some(vec) = self.counties.as_mut() { vec.push(val) ; } else
        { self.counties = Some(vec! [val]) ; }
    }
}
starting work on County
join statements ".left_join(City :: get_table_ref()).inner_join(Country :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: county)] pub struct NewCounty
{ pub version : i64, pub name : String, pub country_id : i64 }
#[derive(Serialize, Clone)] pub struct CountyWithAll
{
    #[serde(flatten)] pub self_data : County, pub cities : Vec < City >, pub
    country : Country,
} impl CountyWithAll
{
    pub fn
    new_builder((self_data, cities, country) :
    (County, Option < City >, Country)) -> Self
    {
        Self
        {
            self_data, cities : if let Some(data) = cities { vec! [data] }
            else { Vec :: new() }, country,
        }
    } pub fn
    insert_data(& mut self, (self_data, cities, country) :
    (County, Option < City >, Country))
    { if let Some(data) = cities { self.cities.push(data) ; } }
} impl County
{
    pub fn get_table_ref() -> crate :: schema :: county :: table
    { return crate :: schema :: county :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: county ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewCounty, conn : & mut MysqlConnection,) -> Result
    < NewCounty, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: county ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: county ::
        table.filter(crate :: schema :: county :: id.eq(uid)).first :: < Self
        > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    CountyWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < CountyWithAll > =
        Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        county ::
        table.left_join(City ::
        get_table_ref()).inner_join(Country ::
        get_table_ref()).select((County :: as_select(), Option :: < City > ::
        as_select(), Country :: as_select())).load :: <
        (County, Option :: < City >, Country) > (conn) ? ; for query_row in
        all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = CountyWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_cities(& self, conn : & mut MysqlConnection) -> Vec < City >
    {
        return City ::
        belonging_to(&
        self).select(City ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn get_country(& self, conn : & mut MysqlConnection) -> Country
    {
        return Country ::
        find(self.country_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    } pub fn find_all_with_cities(conn : & mut MysqlConnection) -> Result <
    Vec < CountyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < CountyLazy > = Vec :: new() ; let mut last_id
        = 0 ; let all_rows = crate :: schema :: county ::
        table.left_join(City ::
        get_table_ref()).select((County :: as_select(), Option :: < City > ::
        as_select())).load :: < (County, Option :: < City >) > (conn) ? ;
        for(self_data, cities) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = cities { data.push_or_set_cities(val) ; }
            } else
            {
                let mut data = CountyLazy :: init(self_data) ; if let
                Some(val) = cities { data.push_or_set_cities(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_country(conn : & mut MysqlConnection) -> Result <
    Vec < CountyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < CountyLazy > = Vec :: new() ; let mut last_id
        = 0 ; let all_rows = crate :: schema :: county ::
        table.inner_join(Country ::
        get_table_ref()).select((County :: as_select(), Country ::
        as_select())).load :: < (County, Country) > (conn) ? ;
        for(self_data, country) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ;
                data.push_or_set_country(country) ;
            } else
            {
                let mut data = CountyLazy :: init(self_data) ;
                data.push_or_set_country(country) ; ; ret_data.push(data) ;
                last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct CountyLazy
{
    #[serde(flatten)] pub self_data : County, pub cities : Option < Vec < City
    > >, pub country : Option < Country >
} impl CountyLazy
{
    pub fn init(self_data : County) -> Self
    { Self { self_data, cities : None, country : None } } pub fn
    push_or_set_cities(& mut self, val : City)
    {
        if let Some(vec) = self.cities.as_mut() { vec.push(val) ; } else
        { self.cities = Some(vec! [val]) ; }
    } pub fn push_or_set_country(& mut self, val : Country)
    { self.country = Some(val) ; }
}
starting work on Currency
join statements ".left_join(AccomodationProperty :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: currency)] pub struct NewCurrency
{ pub version : i64, pub value : String } #[derive(Serialize, Clone)] pub
struct CurrencyWithAll
{
    #[serde(flatten)] pub self_data : Currency, pub accomodation_properties :
    Vec < AccomodationProperty >,
} impl CurrencyWithAll
{
    pub fn
    new_builder((self_data, accomodation_properties) :
    (Currency, Option < AccomodationProperty >)) -> Self
    {
        Self
        {
            self_data, accomodation_properties : if let Some(data) =
            accomodation_properties { vec! [data] } else { Vec :: new() },
        }
    } pub fn
    insert_data(& mut self, (self_data, accomodation_properties) :
    (Currency, Option < AccomodationProperty >))
    {
        if let Some(data) = accomodation_properties
        { self.accomodation_properties.push(data) ; }
    }
} impl Currency
{
    pub fn get_table_ref() -> crate :: schema :: currency :: table
    { return crate :: schema :: currency :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: currency ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewCurrency, conn : & mut MysqlConnection,) ->
    Result < NewCurrency, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: currency ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: currency ::
        table.filter(crate :: schema :: currency :: id.eq(uid)).first :: <
        Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    CurrencyWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < CurrencyWithAll >
        = Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema
        :: currency ::
        table.left_join(AccomodationProperty ::
        get_table_ref()).select((Currency :: as_select(), Option :: <
        AccomodationProperty > :: as_select())).load :: <
        (Currency, Option :: < AccomodationProperty >) > (conn) ? ; for
        query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = CurrencyWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_accomodation_properties(& self, conn : & mut MysqlConnection)
    -> Vec < AccomodationProperty >
    {
        return AccomodationProperty ::
        belonging_to(&
        self).select(AccomodationProperty ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn
    find_all_with_accomodation_properties(conn : & mut MysqlConnection) ->
    Result < Vec < CurrencyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < CurrencyLazy > = Vec :: new() ; let mut
        last_id = 0 ; let all_rows = crate :: schema :: currency ::
        table.left_join(AccomodationProperty ::
        get_table_ref()).select((Currency :: as_select(), Option :: <
        AccomodationProperty > :: as_select())).load :: <
        (Currency, Option :: < AccomodationProperty >) > (conn) ? ;
        for(self_data, accomodation_properties) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = accomodation_properties
                { data.push_or_set_accomodation_properties(val) ; }
            } else
            {
                let mut data = CurrencyLazy :: init(self_data) ; if let
                Some(val) = accomodation_properties
                { data.push_or_set_accomodation_properties(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct CurrencyLazy
{
    #[serde(flatten)] pub self_data : Currency, pub accomodation_properties :
    Option < Vec < AccomodationProperty > >
} impl CurrencyLazy
{
    pub fn init(self_data : Currency) -> Self
    { Self { self_data, accomodation_properties : None } } pub fn
    push_or_set_accomodation_properties(& mut self, val :
    AccomodationProperty)
    {
        if let Some(vec) = self.accomodation_properties.as_mut()
        { vec.push(val) ; } else
        { self.accomodation_properties = Some(vec! [val]) ; }
    }
}
starting work on Language
join statements ".left_join(AccomodationProperty :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: language)] pub struct NewLanguage
{ pub version : i64, pub code : String, pub name : String }
#[derive(Serialize, Clone)] pub struct LanguageWithAll
{
    #[serde(flatten)] pub self_data : Language, pub accomodation_properties :
    Vec < AccomodationProperty >,
} impl LanguageWithAll
{
    pub fn
    new_builder((self_data, accomodation_properties) :
    (Language, Option < AccomodationProperty >)) -> Self
    {
        Self
        {
            self_data, accomodation_properties : if let Some(data) =
            accomodation_properties { vec! [data] } else { Vec :: new() },
        }
    } pub fn
    insert_data(& mut self, (self_data, accomodation_properties) :
    (Language, Option < AccomodationProperty >))
    {
        if let Some(data) = accomodation_properties
        { self.accomodation_properties.push(data) ; }
    }
} impl Language
{
    pub fn get_table_ref() -> crate :: schema :: language :: table
    { return crate :: schema :: language :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: language ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewLanguage, conn : & mut MysqlConnection,) ->
    Result < NewLanguage, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: language ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: language ::
        table.filter(crate :: schema :: language :: id.eq(uid)).first :: <
        Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    LanguageWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < LanguageWithAll >
        = Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema
        :: language ::
        table.left_join(AccomodationProperty ::
        get_table_ref()).select((Language :: as_select(), Option :: <
        AccomodationProperty > :: as_select())).load :: <
        (Language, Option :: < AccomodationProperty >) > (conn) ? ; for
        query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = LanguageWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_accomodation_properties(& self, conn : & mut MysqlConnection)
    -> Vec < AccomodationProperty >
    {
        return AccomodationProperty ::
        belonging_to(&
        self).select(AccomodationProperty ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn
    find_all_with_accomodation_properties(conn : & mut MysqlConnection) ->
    Result < Vec < LanguageLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < LanguageLazy > = Vec :: new() ; let mut
        last_id = 0 ; let all_rows = crate :: schema :: language ::
        table.left_join(AccomodationProperty ::
        get_table_ref()).select((Language :: as_select(), Option :: <
        AccomodationProperty > :: as_select())).load :: <
        (Language, Option :: < AccomodationProperty >) > (conn) ? ;
        for(self_data, accomodation_properties) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = accomodation_properties
                { data.push_or_set_accomodation_properties(val) ; }
            } else
            {
                let mut data = LanguageLazy :: init(self_data) ; if let
                Some(val) = accomodation_properties
                { data.push_or_set_accomodation_properties(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct LanguageLazy
{
    #[serde(flatten)] pub self_data : Language, pub accomodation_properties :
    Option < Vec < AccomodationProperty > >
} impl LanguageLazy
{
    pub fn init(self_data : Language) -> Self
    { Self { self_data, accomodation_properties : None } } pub fn
    push_or_set_accomodation_properties(& mut self, val :
    AccomodationProperty)
    {
        if let Some(vec) = self.accomodation_properties.as_mut()
        { vec.push(val) ; } else
        { self.accomodation_properties = Some(vec! [val]) ; }
    }
}
starting work on MealPlan
join statements ".left_join(Reservation :: get_table_ref()).left_join(RoomMealPlan :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: meal_plan)] pub struct NewMealPlan
{ pub name : String, pub description : Option < String > }
#[derive(Serialize, Clone)] pub struct MealPlanWithAll
{
    #[serde(flatten)] pub self_data : MealPlan, pub reservations : Vec <
    Reservation >, pub room_meal_plans : Vec < RoomMealPlan >,
} impl MealPlanWithAll
{
    pub fn
    new_builder((self_data, reservations, room_meal_plans) :
    (MealPlan, Option < Reservation >, Option < RoomMealPlan >)) -> Self
    {
        Self
        {
            self_data, reservations : if let Some(data) = reservations
            { vec! [data] } else { Vec :: new() }, room_meal_plans : if let
            Some(data) = room_meal_plans { vec! [data] } else
            { Vec :: new() },
        }
    } pub fn
    insert_data(& mut self, (self_data, reservations, room_meal_plans) :
    (MealPlan, Option < Reservation >, Option < RoomMealPlan >))
    {
        if let Some(data) = reservations { self.reservations.push(data) ; } if
        let Some(data) = room_meal_plans { self.room_meal_plans.push(data) ; }
    }
} impl MealPlan
{
    pub fn get_table_ref() -> crate :: schema :: meal_plan :: table
    { return crate :: schema :: meal_plan :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: meal_plan ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewMealPlan, conn : & mut MysqlConnection,) ->
    Result < NewMealPlan, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: meal_plan ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: meal_plan ::
        table.filter(crate :: schema :: meal_plan :: id.eq(uid)).first :: <
        Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    MealPlanWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < MealPlanWithAll >
        = Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema
        :: meal_plan ::
        table.left_join(Reservation ::
        get_table_ref()).left_join(RoomMealPlan ::
        get_table_ref()).select((MealPlan :: as_select(), Option :: <
        Reservation > :: as_select(), Option :: < RoomMealPlan > ::
        as_select())).load :: <
        (MealPlan, Option :: < Reservation >, Option :: < RoomMealPlan >) >
        (conn) ? ; for query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = MealPlanWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_reservations(& self, conn : & mut MysqlConnection) -> Vec <
    Reservation >
    {
        return Reservation ::
        belonging_to(&
        self).select(Reservation ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn get_room_meal_plans(& self, conn : & mut MysqlConnection) -> Vec
    < RoomMealPlan >
    {
        return RoomMealPlan ::
        belonging_to(&
        self).select(RoomMealPlan ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn find_all_with_reservations(conn : & mut MysqlConnection) ->
    Result < Vec < MealPlanLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < MealPlanLazy > = Vec :: new() ; let mut
        last_id = 0 ; let all_rows = crate :: schema :: meal_plan ::
        table.left_join(Reservation ::
        get_table_ref()).select((MealPlan :: as_select(), Option :: <
        Reservation > :: as_select())).load :: <
        (MealPlan, Option :: < Reservation >) > (conn) ? ;
        for(self_data, reservations) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = reservations { data.push_or_set_reservations(val) ; }
            } else
            {
                let mut data = MealPlanLazy :: init(self_data) ; if let
                Some(val) = reservations
                { data.push_or_set_reservations(val) ; } ; ret_data.push(data)
                ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_room_meal_plans(conn : & mut MysqlConnection) ->
    Result < Vec < MealPlanLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < MealPlanLazy > = Vec :: new() ; let mut
        last_id = 0 ; let all_rows = crate :: schema :: meal_plan ::
        table.left_join(RoomMealPlan ::
        get_table_ref()).select((MealPlan :: as_select(), Option :: <
        RoomMealPlan > :: as_select())).load :: <
        (MealPlan, Option :: < RoomMealPlan >) > (conn) ? ;
        for(self_data, room_meal_plans) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = room_meal_plans { data.push_or_set_room_meal_plans(val) ; }
            } else
            {
                let mut data = MealPlanLazy :: init(self_data) ; if let
                Some(val) = room_meal_plans
                { data.push_or_set_room_meal_plans(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct MealPlanLazy
{
    #[serde(flatten)] pub self_data : MealPlan, pub reservations : Option <
    Vec < Reservation > >, pub room_meal_plans : Option < Vec < RoomMealPlan >
    >
} impl MealPlanLazy
{
    pub fn init(self_data : MealPlan) -> Self
    { Self { self_data, reservations : None, room_meal_plans : None } } pub fn
    push_or_set_reservations(& mut self, val : Reservation)
    {
        if let Some(vec) = self.reservations.as_mut() { vec.push(val) ; } else
        { self.reservations = Some(vec! [val]) ; }
    } pub fn push_or_set_room_meal_plans(& mut self, val : RoomMealPlan)
    {
        if let Some(vec) = self.room_meal_plans.as_mut() { vec.push(val) ; }
        else { self.room_meal_plans = Some(vec! [val]) ; }
    }
}
starting work on PhotoTag
join statements ""
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: photo_tag)] pub struct NewPhotoTag
{ pub version : i64, pub name : String } impl PhotoTag
{
    pub fn get_table_ref() -> crate :: schema :: photo_tag :: table
    { return crate :: schema :: photo_tag :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: photo_tag ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewPhotoTag, conn : & mut MysqlConnection,) ->
    Result < NewPhotoTag, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: photo_tag ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: photo_tag ::
        table.filter(crate :: schema :: photo_tag :: id.eq(uid)).first :: <
        Self > (conn).optional() ? ; Ok(result)
    }
}
starting work on Reservation
join statements ".left_join(MealPlan :: get_table_ref()).left_join(Room :: get_table_ref()).inner_join(RoomTypeAvailabilityRate :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: reservation)] pub struct
NewReservation
{
    pub version : i64, pub room_id : Option < i64 >, pub occupancy : i32, pub
    date : NaiveDateTime, pub room_type_availability_id : i64, pub price :
    f32, pub meal_plan_id : Option < i64 >, pub status : i32
} #[derive(Serialize, Clone)] pub struct ReservationWithAll
{
    #[serde(flatten)] pub self_data : Reservation, pub room : Option < Room >,
    pub room_type_availability : RoomTypeAvailabilityRate, pub meal_plan :
    Option < MealPlan >,
} impl ReservationWithAll
{
    pub fn
    new_builder((self_data, room, room_type_availability, meal_plan) :
    (Reservation, Option < Room >, RoomTypeAvailabilityRate, Option < MealPlan
    >)) -> Self
    { Self { self_data, room, room_type_availability, meal_plan, } } pub fn
    insert_data(& mut self,
    (self_data, room, room_type_availability, meal_plan) :
    (Reservation, Option < Room >, RoomTypeAvailabilityRate, Option < MealPlan
    >)) {}
} impl Reservation
{
    pub fn get_table_ref() -> crate :: schema :: reservation :: table
    { return crate :: schema :: reservation :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: reservation ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewReservation, conn : & mut MysqlConnection,) ->
    Result < NewReservation, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: reservation ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: reservation ::
        table.filter(crate :: schema :: reservation :: id.eq(uid)).first :: <
        Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    ReservationWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < ReservationWithAll
        > = Vec :: new() ; let mut last_id = 0 ; let all_rows = crate ::
        schema :: reservation ::
        table.left_join(MealPlan ::
        get_table_ref()).left_join(Room ::
        get_table_ref()).inner_join(RoomTypeAvailabilityRate ::
        get_table_ref()).select((Reservation :: as_select(), Option :: < Room
        > :: as_select(), RoomTypeAvailabilityRate :: as_select(), Option :: <
        MealPlan > :: as_select())).load :: <
        (Reservation, Option :: < Room >, RoomTypeAvailabilityRate, Option ::
        < MealPlan >) > (conn) ? ; for query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = ReservationWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_room(& self, conn : & mut MysqlConnection) -> Option < Room >
    {
        if let Some(fk_value) = self.room_id
        {
            return Room ::
            find(fk_value, conn).expect("could not fetch relation") ;
        } else { return None ; }
    } pub fn get_room_type_availability(& self, conn : & mut MysqlConnection)
    -> RoomTypeAvailabilityRate
    {
        return RoomTypeAvailabilityRate ::
        find(self.room_type_availability_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    } pub fn get_meal_plan(& self, conn : & mut MysqlConnection) -> Option <
    MealPlan >
    {
        if let Some(fk_value) = self.meal_plan_id
        {
            return MealPlan ::
            find(fk_value, conn).expect("could not fetch relation") ;
        } else { return None ; }
    } pub fn find_all_with_meal_plan(conn : & mut MysqlConnection) -> Result <
    Vec < ReservationLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < ReservationLazy > = Vec :: new() ; let mut
        last_id = 0 ; let all_rows = crate :: schema :: reservation ::
        table.left_join(MealPlan ::
        get_table_ref()).select((Reservation :: as_select(), Option :: <
        MealPlan > :: as_select())).load :: <
        (Reservation, Option :: < MealPlan >) > (conn) ? ;
        for(self_data, meal_plan) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = meal_plan { data.push_or_set_meal_plan(val) ; }
            } else
            {
                let mut data = ReservationLazy :: init(self_data) ; if let
                Some(val) = meal_plan { data.push_or_set_meal_plan(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_room(conn : & mut MysqlConnection) -> Result < Vec
    < ReservationLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < ReservationLazy > = Vec :: new() ; let mut
        last_id = 0 ; let all_rows = crate :: schema :: reservation ::
        table.left_join(Room ::
        get_table_ref()).select((Reservation :: as_select(), Option :: < Room
        > :: as_select())).load :: < (Reservation, Option :: < Room >) >
        (conn) ? ; for(self_data, room) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = room { data.push_or_set_room(val) ; }
            } else
            {
                let mut data = ReservationLazy :: init(self_data) ; if let
                Some(val) = room { data.push_or_set_room(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn
    find_all_with_room_type_availability(conn : & mut MysqlConnection) ->
    Result < Vec < ReservationLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < ReservationLazy > = Vec :: new() ; let mut
        last_id = 0 ; let all_rows = crate :: schema :: reservation ::
        table.inner_join(RoomTypeAvailabilityRate ::
        get_table_ref()).select((Reservation :: as_select(),
        RoomTypeAvailabilityRate :: as_select())).load :: <
        (Reservation, RoomTypeAvailabilityRate) > (conn) ? ;
        for(self_data, room_type_availability) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ;
                data.push_or_set_room_type_availability(room_type_availability)
                ;
            } else
            {
                let mut data = ReservationLazy :: init(self_data) ;
                data.push_or_set_room_type_availability(room_type_availability)
                ; ; ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct ReservationLazy
{
    #[serde(flatten)] pub self_data : Reservation, pub room : Option < Room >,
    pub room_type_availability : Option < RoomTypeAvailabilityRate >, pub
    meal_plan : Option < MealPlan >
} impl ReservationLazy
{
    pub fn init(self_data : Reservation) -> Self
    {
        Self
        {
            self_data, room : None, room_type_availability : None, meal_plan :
            None
        }
    } pub fn push_or_set_meal_plan(& mut self, val : MealPlan)
    { self.meal_plan = Some(val) ; } pub fn
    push_or_set_room(& mut self, val : Room) { self.room = Some(val) ; } pub
    fn
    push_or_set_room_type_availability(& mut self, val :
    RoomTypeAvailabilityRate) { self.room_type_availability = Some(val) ; }
}
starting work on Role
join statements ".left_join(AccomodationProperty :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: role)] pub struct NewRole
{ pub version : i64, pub authority : String } #[derive(Serialize, Clone)] pub
struct RoleWithAll
{
    #[serde(flatten)] pub self_data : Role, pub accomodation_properties : Vec
    < AccomodationProperty >,
} impl RoleWithAll
{
    pub fn
    new_builder((self_data, accomodation_properties) :
    (Role, Option < AccomodationProperty >)) -> Self
    {
        Self
        {
            self_data, accomodation_properties : if let Some(data) =
            accomodation_properties { vec! [data] } else { Vec :: new() },
        }
    } pub fn
    insert_data(& mut self, (self_data, accomodation_properties) :
    (Role, Option < AccomodationProperty >))
    {
        if let Some(data) = accomodation_properties
        { self.accomodation_properties.push(data) ; }
    }
} impl Role
{
    pub fn get_table_ref() -> crate :: schema :: role :: table
    { return crate :: schema :: role :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: role ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewRole, conn : & mut MysqlConnection,) -> Result <
    NewRole, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: role ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: role ::
        table.filter(crate :: schema :: role :: id.eq(uid)).first :: < Self >
        (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    RoleWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < RoleWithAll > =
        Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        role ::
        table.left_join(AccomodationProperty ::
        get_table_ref()).select((Role :: as_select(), Option :: <
        AccomodationProperty > :: as_select())).load :: <
        (Role, Option :: < AccomodationProperty >) > (conn) ? ; for query_row
        in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = RoleWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_accomodation_properties(& self, conn : & mut MysqlConnection)
    -> Vec < AccomodationProperty >
    {
        return AccomodationProperty ::
        belonging_to(&
        self).select(AccomodationProperty ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn
    find_all_with_accomodation_properties(conn : & mut MysqlConnection) ->
    Result < Vec < RoleLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoleLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: role ::
        table.left_join(AccomodationProperty ::
        get_table_ref()).select((Role :: as_select(), Option :: <
        AccomodationProperty > :: as_select())).load :: <
        (Role, Option :: < AccomodationProperty >) > (conn) ? ;
        for(self_data, accomodation_properties) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = accomodation_properties
                { data.push_or_set_accomodation_properties(val) ; }
            } else
            {
                let mut data = RoleLazy :: init(self_data) ; if let Some(val)
                = accomodation_properties
                { data.push_or_set_accomodation_properties(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct RoleLazy
{
    #[serde(flatten)] pub self_data : Role, pub accomodation_properties :
    Option < Vec < AccomodationProperty > >
} impl RoleLazy
{
    pub fn init(self_data : Role) -> Self
    { Self { self_data, accomodation_properties : None } } pub fn
    push_or_set_accomodation_properties(& mut self, val :
    AccomodationProperty)
    {
        if let Some(vec) = self.accomodation_properties.as_mut()
        { vec.push(val) ; } else
        { self.accomodation_properties = Some(vec! [val]) ; }
    }
}
starting work on Room
query path guards: [Ident { ident: "accomodation_property", span: #0 bytes(9827..9848) }, Dot, Ident { ident: "role", span: #0 bytes(9849..9853) }, Dot, Ident { ident: "authority", span: #0 bytes(9854..9863) }]
join statements ".inner_join(AccomodationProperty :: get_table_ref()).left_join(RoomToFacility ::\nget_table_ref().left_join(RoomFacility :: get_table_ref())).inner_join(RoomPricingType :: get_table_ref()).left_join(Reservation :: get_table_ref()).left_join(RoomMealPlan :: get_table_ref()).left_join(RoomPhoto :: get_table_ref()).left_join(RoomTypeAvailabilityRate :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: room)] pub struct NewRoom
{
    pub version : i64, pub default_occupancy : i32, pub minimum_guests : i32,
    pub name : String, pub pricing_type_id : i64, pub accomodation_property_id
    : i64, pub baby_coats : i32, pub maximum_guests : i32, pub room_view :
    Option < String >, pub floor : Option < i32 >, pub description : Option <
    String >, pub size_measurement : f32, pub size_measurement_unit : String
} #[derive(Serialize, Clone)] pub struct RoomWithAll
{
    #[serde(flatten)] pub self_data : Room, pub facilities : Vec <
    RoomFacility >, pub reservations : Vec < Reservation >, pub
    room_meal_plans : Vec < RoomMealPlan >, pub room_photos : Vec < RoomPhoto
    >, pub room_type_availability_rates : Vec < RoomTypeAvailabilityRate >,
    pub pricing_type : RoomPricingType, pub accomodation_property :
    AccomodationProperty,
} impl RoomWithAll
{
    pub fn
    new_builder((self_data, facilities, reservations, room_meal_plans,
    room_photos, room_type_availability_rates, pricing_type,
    accomodation_property) :
    (Room, Option < RoomFacility >, Option < Reservation >, Option <
    RoomMealPlan >, Option < RoomPhoto >, Option < RoomTypeAvailabilityRate >,
    RoomPricingType, AccomodationProperty)) -> Self
    {
        Self
        {
            self_data, facilities : if let Some(data) = facilities
            { vec! [data] } else { Vec :: new() }, reservations : if let
            Some(data) = reservations { vec! [data] } else { Vec :: new() },
            room_meal_plans : if let Some(data) = room_meal_plans
            { vec! [data] } else { Vec :: new() }, room_photos : if let
            Some(data) = room_photos { vec! [data] } else { Vec :: new() },
            room_type_availability_rates : if let Some(data) =
            room_type_availability_rates { vec! [data] } else
            { Vec :: new() }, pricing_type, accomodation_property,
        }
    } pub fn
    insert_data(& mut self,
    (self_data, facilities, reservations, room_meal_plans, room_photos,
    room_type_availability_rates, pricing_type, accomodation_property) :
    (Room, Option < RoomFacility >, Option < Reservation >, Option <
    RoomMealPlan >, Option < RoomPhoto >, Option < RoomTypeAvailabilityRate >,
    RoomPricingType, AccomodationProperty))
    {
        if let Some(data) = facilities { self.facilities.push(data) ; } if let
        Some(data) = reservations { self.reservations.push(data) ; } if let
        Some(data) = room_meal_plans { self.room_meal_plans.push(data) ; } if
        let Some(data) = room_photos { self.room_photos.push(data) ; } if let
        Some(data) = room_type_availability_rates
        { self.room_type_availability_rates.push(data) ; }
    }
} impl Room
{
    pub fn get_table_ref() -> crate :: schema :: room :: table
    { return crate :: schema :: room :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: room ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewRoom, conn : & mut MysqlConnection,) -> Result <
    NewRoom, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: room ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: room ::
        table.filter(crate :: schema :: room :: id.eq(uid)).first :: < Self >
        (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    RoomWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < RoomWithAll > =
        Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        room ::
        table.inner_join(AccomodationProperty ::
        get_table_ref()).left_join(RoomToFacility ::
        get_table_ref().left_join(RoomFacility ::
        get_table_ref())).inner_join(RoomPricingType ::
        get_table_ref()).left_join(Reservation ::
        get_table_ref()).left_join(RoomMealPlan ::
        get_table_ref()).left_join(RoomPhoto ::
        get_table_ref()).left_join(RoomTypeAvailabilityRate ::
        get_table_ref()).select((Room :: as_select(), Option :: < RoomFacility
        > :: as_select(), Option :: < Reservation > :: as_select(), Option ::
        < RoomMealPlan > :: as_select(), Option :: < RoomPhoto > ::
        as_select(), Option :: < RoomTypeAvailabilityRate > :: as_select(),
        RoomPricingType :: as_select(), AccomodationProperty ::
        as_select())).load :: <
        (Room, Option :: < RoomFacility >, Option :: < Reservation >, Option
        :: < RoomMealPlan >, Option :: < RoomPhoto >, Option :: <
        RoomTypeAvailabilityRate >, RoomPricingType, AccomodationProperty) >
        (conn) ? ; for query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = RoomWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_facilities(& self, conn : & mut MysqlConnection) -> Vec <
    RoomFacility >
    {
        return RoomToFacility ::
        belonging_to(&
        self).inner_join(RoomFacility ::
        get_table_ref()).select(RoomFacility ::
        as_select()).load(conn).expect("error running query to fetch many to many relationship")
        ;
    } pub fn get_reservations(& self, conn : & mut MysqlConnection) -> Vec <
    Reservation >
    {
        return Reservation ::
        belonging_to(&
        self).select(Reservation ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn get_room_meal_plans(& self, conn : & mut MysqlConnection) -> Vec
    < RoomMealPlan >
    {
        return RoomMealPlan ::
        belonging_to(&
        self).select(RoomMealPlan ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn get_room_photos(& self, conn : & mut MysqlConnection) -> Vec <
    RoomPhoto >
    {
        return RoomPhoto ::
        belonging_to(&
        self).select(RoomPhoto ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn
    get_room_type_availability_rates(& self, conn : & mut MysqlConnection) ->
    Vec < RoomTypeAvailabilityRate >
    {
        return RoomTypeAvailabilityRate ::
        belonging_to(&
        self).select(RoomTypeAvailabilityRate ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn get_pricing_type(& self, conn : & mut MysqlConnection) ->
    RoomPricingType
    {
        return RoomPricingType ::
        find(self.pricing_type_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    } pub fn get_accomodation_property(& self, conn : & mut MysqlConnection)
    -> AccomodationProperty
    {
        return AccomodationProperty ::
        find(self.accomodation_property_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    } pub fn find_all_with_accomodation_property(conn : & mut MysqlConnection)
    -> Result < Vec < RoomLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: room ::
        table.inner_join(AccomodationProperty ::
        get_table_ref()).select((Room :: as_select(), AccomodationProperty ::
        as_select())).load :: < (Room, AccomodationProperty) > (conn) ? ;
        for(self_data, accomodation_property) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ;
                data.push_or_set_accomodation_property(accomodation_property)
                ;
            } else
            {
                let mut data = RoomLazy :: init(self_data) ;
                data.push_or_set_accomodation_property(accomodation_property)
                ; ; ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_facilities(conn : & mut MysqlConnection) -> Result
    < Vec < RoomLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: room ::
        table.left_join(RoomToFacility ::
        get_table_ref().left_join(RoomFacility ::
        get_table_ref())).select((Room :: as_select(), Option :: <
        RoomFacility > :: as_select())).load :: <
        (Room, Option :: < RoomFacility >) > (conn) ? ;
        for(self_data, facilities) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = facilities { data.push_or_set_facilities(val) ; }
            } else
            {
                let mut data = RoomLazy :: init(self_data) ; if let Some(val)
                = facilities { data.push_or_set_facilities(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_pricing_type(conn : & mut MysqlConnection) ->
    Result < Vec < RoomLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: room ::
        table.inner_join(RoomPricingType ::
        get_table_ref()).select((Room :: as_select(), RoomPricingType ::
        as_select())).load :: < (Room, RoomPricingType) > (conn) ? ;
        for(self_data, pricing_type) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ;
                data.push_or_set_pricing_type(pricing_type) ;
            } else
            {
                let mut data = RoomLazy :: init(self_data) ;
                data.push_or_set_pricing_type(pricing_type) ; ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_reservations(conn : & mut MysqlConnection) ->
    Result < Vec < RoomLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: room ::
        table.left_join(Reservation ::
        get_table_ref()).select((Room :: as_select(), Option :: < Reservation
        > :: as_select())).load :: < (Room, Option :: < Reservation >) >
        (conn) ? ; for(self_data, reservations) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = reservations { data.push_or_set_reservations(val) ; }
            } else
            {
                let mut data = RoomLazy :: init(self_data) ; if let Some(val)
                = reservations { data.push_or_set_reservations(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_room_meal_plans(conn : & mut MysqlConnection) ->
    Result < Vec < RoomLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: room ::
        table.left_join(RoomMealPlan ::
        get_table_ref()).select((Room :: as_select(), Option :: < RoomMealPlan
        > :: as_select())).load :: < (Room, Option :: < RoomMealPlan >) >
        (conn) ? ; for(self_data, room_meal_plans) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = room_meal_plans { data.push_or_set_room_meal_plans(val) ; }
            } else
            {
                let mut data = RoomLazy :: init(self_data) ; if let Some(val)
                = room_meal_plans { data.push_or_set_room_meal_plans(val) ; }
                ; ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_room_photos(conn : & mut MysqlConnection) -> Result
    < Vec < RoomLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: room ::
        table.left_join(RoomPhoto ::
        get_table_ref()).select((Room :: as_select(), Option :: < RoomPhoto >
        :: as_select())).load :: < (Room, Option :: < RoomPhoto >) > (conn) ?
        ; for(self_data, room_photos) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = room_photos { data.push_or_set_room_photos(val) ; }
            } else
            {
                let mut data = RoomLazy :: init(self_data) ; if let Some(val)
                = room_photos { data.push_or_set_room_photos(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn
    find_all_with_room_type_availability_rates(conn : & mut MysqlConnection)
    -> Result < Vec < RoomLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: room ::
        table.left_join(RoomTypeAvailabilityRate ::
        get_table_ref()).select((Room :: as_select(), Option :: <
        RoomTypeAvailabilityRate > :: as_select())).load :: <
        (Room, Option :: < RoomTypeAvailabilityRate >) > (conn) ? ;
        for(self_data, room_type_availability_rates) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = room_type_availability_rates
                { data.push_or_set_room_type_availability_rates(val) ; }
            } else
            {
                let mut data = RoomLazy :: init(self_data) ; if let Some(val)
                = room_type_availability_rates
                { data.push_or_set_room_type_availability_rates(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct RoomLazy
{
    #[serde(flatten)] pub self_data : Room, pub facilities : Option < Vec <
    RoomFacility > >, pub reservations : Option < Vec < Reservation > >, pub
    room_meal_plans : Option < Vec < RoomMealPlan > >, pub room_photos :
    Option < Vec < RoomPhoto > >, pub room_type_availability_rates : Option <
    Vec < RoomTypeAvailabilityRate > >, pub pricing_type : Option <
    RoomPricingType >, pub accomodation_property : Option <
    AccomodationProperty >
} impl RoomLazy
{
    pub fn init(self_data : Room) -> Self
    {
        Self
        {
            self_data, facilities : None, reservations : None, room_meal_plans
            : None, room_photos : None, room_type_availability_rates : None,
            pricing_type : None, accomodation_property : None
        }
    } pub fn
    push_or_set_accomodation_property(& mut self, val : AccomodationProperty)
    { self.accomodation_property = Some(val) ; } pub fn
    push_or_set_facilities(& mut self, val : RoomFacility)
    {
        if let Some(vec) = self.facilities.as_mut() { vec.push(val) ; } else
        { self.facilities = Some(vec! [val]) ; }
    } pub fn push_or_set_pricing_type(& mut self, val : RoomPricingType)
    { self.pricing_type = Some(val) ; } pub fn
    push_or_set_reservations(& mut self, val : Reservation)
    {
        if let Some(vec) = self.reservations.as_mut() { vec.push(val) ; } else
        { self.reservations = Some(vec! [val]) ; }
    } pub fn push_or_set_room_meal_plans(& mut self, val : RoomMealPlan)
    {
        if let Some(vec) = self.room_meal_plans.as_mut() { vec.push(val) ; }
        else { self.room_meal_plans = Some(vec! [val]) ; }
    } pub fn push_or_set_room_photos(& mut self, val : RoomPhoto)
    {
        if let Some(vec) = self.room_photos.as_mut() { vec.push(val) ; } else
        { self.room_photos = Some(vec! [val]) ; }
    } pub fn
    push_or_set_room_type_availability_rates(& mut self, val :
    RoomTypeAvailabilityRate)
    {
        if let Some(vec) = self.room_type_availability_rates.as_mut()
        { vec.push(val) ; } else
        { self.room_type_availability_rates = Some(vec! [val]) ; }
    }
}
starting work on RoomFacility
join statements ""
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: room_facilities)] pub struct
NewRoomFacility
{
    pub version : i64, pub name : String, pub rma : Option < String >, pub
    booking_extended_amenities : Option < String >
} impl RoomFacility
{
    pub fn get_table_ref() -> crate :: schema :: room_facilities :: table
    { return crate :: schema :: room_facilities :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: room_facilities ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewRoomFacility, conn : & mut MysqlConnection,) ->
    Result < NewRoomFacility, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: room_facilities ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: room_facilities ::
        table.filter(crate :: schema :: room_facilities :: id.eq(uid)).first
        :: < Self > (conn).optional() ? ; Ok(result)
    }
}
starting work on RoomMealPlan
join statements ".inner_join(MealPlan :: get_table_ref()).inner_join(Room :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: room_meal_plan)] pub struct
NewRoomMealPlan { pub room_meal_plan_id : i64, pub meal_plan_id : i64 }
#[derive(Serialize, Clone)] pub struct RoomMealPlanWithAll
{
    #[serde(flatten)] pub self_data : RoomMealPlan, pub room_meal_plan : Room,
    pub meal_plan : MealPlan,
} impl RoomMealPlanWithAll
{
    pub fn
    new_builder((self_data, room_meal_plan, meal_plan) :
    (RoomMealPlan, Room, MealPlan)) -> Self
    { Self { self_data, room_meal_plan, meal_plan, } } pub fn
    insert_data(& mut self, (self_data, room_meal_plan, meal_plan) :
    (RoomMealPlan, Room, MealPlan)) {}
} impl RoomMealPlan
{
    pub fn get_table_ref() -> crate :: schema :: room_meal_plan :: table
    { return crate :: schema :: room_meal_plan :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: room_meal_plan ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewRoomMealPlan, conn : & mut MysqlConnection,) ->
    Result < NewRoomMealPlan, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: room_meal_plan ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn
    find(meal_plan_id : i64, room_meal_plan_id : i64, conn : & mut
    MysqlConnection,) -> Result < Option < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: room_meal_plan ::
        table.filter(crate :: schema :: room_meal_plan ::
        room_meal_plan_id.eq(room_meal_plan_id)).filter(crate :: schema ::
        room_meal_plan :: meal_plan_id.eq(meal_plan_id)).first :: < Self >
        (conn).optional() ? ; Ok(result)
    } pub fn get_room_meal_plan(& self, conn : & mut MysqlConnection) -> Room
    {
        return Room ::
        find(self.room_meal_plan_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    } pub fn get_meal_plan(& self, conn : & mut MysqlConnection) -> MealPlan
    {
        return MealPlan ::
        find(self.meal_plan_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    }
} #[derive(Serialize, Clone)] pub struct RoomMealPlanLazy
{
    #[serde(flatten)] pub self_data : RoomMealPlan, pub room_meal_plan :
    Option < Room >, pub meal_plan : Option < MealPlan >
} impl RoomMealPlanLazy
{
    pub fn init(self_data : RoomMealPlan) -> Self
    { Self { self_data, room_meal_plan : None, meal_plan : None } } pub fn
    push_or_set_meal_plan(& mut self, val : MealPlan)
    { self.meal_plan = Some(val) ; } pub fn
    push_or_set_room_meal_plan(& mut self, val : Room)
    { self.room_meal_plan = Some(val) ; }
}
starting work on RoomPhoto
join statements ".inner_join(Room :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: room_photo)] pub struct NewRoomPhoto
{
    pub version : i64, pub room_id : i64, pub file_size : Option < String >,
    pub rank_sort : i32, pub file_name : String
} #[derive(Serialize, Clone)] pub struct RoomPhotoWithAll
{ #[serde(flatten)] pub self_data : RoomPhoto, pub room : Room, } impl
RoomPhotoWithAll
{
    pub fn new_builder((self_data, room) : (RoomPhoto, Room)) -> Self
    { Self { self_data, room, } } pub fn
    insert_data(& mut self, (self_data, room) : (RoomPhoto, Room)) {}
} impl RoomPhoto
{
    pub fn get_table_ref() -> crate :: schema :: room_photo :: table
    { return crate :: schema :: room_photo :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: room_photo ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewRoomPhoto, conn : & mut MysqlConnection,) ->
    Result < NewRoomPhoto, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: room_photo ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: room_photo ::
        table.filter(crate :: schema :: room_photo :: id.eq(uid)).first :: <
        Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    RoomPhotoWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < RoomPhotoWithAll >
        = Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema
        :: room_photo ::
        table.inner_join(Room ::
        get_table_ref()).select((RoomPhoto :: as_select(), Room ::
        as_select())).load :: < (RoomPhoto, Room) > (conn) ? ; for query_row
        in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = RoomPhotoWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_room(& self, conn : & mut MysqlConnection) -> Room
    {
        return Room ::
        find(self.room_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    } pub fn find_all_with_room(conn : & mut MysqlConnection) -> Result < Vec
    < RoomPhotoLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomPhotoLazy > = Vec :: new() ; let mut
        last_id = 0 ; let all_rows = crate :: schema :: room_photo ::
        table.inner_join(Room ::
        get_table_ref()).select((RoomPhoto :: as_select(), Room ::
        as_select())).load :: < (RoomPhoto, Room) > (conn) ? ;
        for(self_data, room) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ;
                data.push_or_set_room(room) ;
            } else
            {
                let mut data = RoomPhotoLazy :: init(self_data) ;
                data.push_or_set_room(room) ; ; ret_data.push(data) ; last_id
                = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct RoomPhotoLazy
{ #[serde(flatten)] pub self_data : RoomPhoto, pub room : Option < Room > }
impl RoomPhotoLazy
{
    pub fn init(self_data : RoomPhoto) -> Self
    { Self { self_data, room : None } } pub fn
    push_or_set_room(& mut self, val : Room) { self.room = Some(val) ; }
}
starting work on RoomPricingType
join statements ".left_join(Room :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: room_pricing_type)] pub struct
NewRoomPricingType { pub version : i64, pub name : String }
#[derive(Serialize, Clone)] pub struct RoomPricingTypeWithAll
{
    #[serde(flatten)] pub self_data : RoomPricingType, pub rooms : Vec < Room
    >,
} impl RoomPricingTypeWithAll
{
    pub fn
    new_builder((self_data, rooms) : (RoomPricingType, Option < Room >)) ->
    Self
    {
        Self
        {
            self_data, rooms : if let Some(data) = rooms { vec! [data] } else
            { Vec :: new() },
        }
    } pub fn
    insert_data(& mut self, (self_data, rooms) :
    (RoomPricingType, Option < Room >))
    { if let Some(data) = rooms { self.rooms.push(data) ; } }
} impl RoomPricingType
{
    pub fn get_table_ref() -> crate :: schema :: room_pricing_type :: table
    { return crate :: schema :: room_pricing_type :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: room_pricing_type ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewRoomPricingType, conn : & mut MysqlConnection,)
    -> Result < NewRoomPricingType, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: room_pricing_type ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: room_pricing_type ::
        table.filter(crate :: schema :: room_pricing_type :: id.eq(uid)).first
        :: < Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    RoomPricingTypeWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec <
        RoomPricingTypeWithAll > = Vec :: new() ; let mut last_id = 0 ; let
        all_rows = crate :: schema :: room_pricing_type ::
        table.left_join(Room ::
        get_table_ref()).select((RoomPricingType :: as_select(), Option :: <
        Room > :: as_select())).load :: <
        (RoomPricingType, Option :: < Room >) > (conn) ? ; for query_row in
        all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = RoomPricingTypeWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_rooms(& self, conn : & mut MysqlConnection) -> Vec < Room >
    {
        return Room ::
        belonging_to(&
        self).select(Room ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn find_all_with_rooms(conn : & mut MysqlConnection) -> Result < Vec
    < RoomPricingTypeLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomPricingTypeLazy > = Vec :: new() ; let
        mut last_id = 0 ; let all_rows = crate :: schema :: room_pricing_type
        ::
        table.left_join(Room ::
        get_table_ref()).select((RoomPricingType :: as_select(), Option :: <
        Room > :: as_select())).load :: <
        (RoomPricingType, Option :: < Room >) > (conn) ? ;
        for(self_data, rooms) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = rooms { data.push_or_set_rooms(val) ; }
            } else
            {
                let mut data = RoomPricingTypeLazy :: init(self_data) ; if let
                Some(val) = rooms { data.push_or_set_rooms(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct RoomPricingTypeLazy
{
    #[serde(flatten)] pub self_data : RoomPricingType, pub rooms : Option <
    Vec < Room > >
} impl RoomPricingTypeLazy
{
    pub fn init(self_data : RoomPricingType) -> Self
    { Self { self_data, rooms : None } } pub fn
    push_or_set_rooms(& mut self, val : Room)
    {
        if let Some(vec) = self.rooms.as_mut() { vec.push(val) ; } else
        { self.rooms = Some(vec! [val]) ; }
    }
}
starting work on RoomToFacility
join statements ""
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: room_to_facilities)] pub struct
NewRoomToFacility { pub room_id : i64, pub room_facility_id : i64 } impl
RoomToFacility
{
    pub fn get_table_ref() -> crate :: schema :: room_to_facilities :: table
    { return crate :: schema :: room_to_facilities :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: room_to_facilities ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewRoomToFacility, conn : & mut MysqlConnection,)
    -> Result < NewRoomToFacility, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: room_to_facilities ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn
    find(room_facility_id : i64, room_id : i64, conn : & mut MysqlConnection,)
    -> Result < Option < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: room_to_facilities ::
        table.filter(crate :: schema :: room_to_facilities ::
        room_id.eq(room_id)).filter(crate :: schema :: room_to_facilities ::
        room_facility_id.eq(room_facility_id)).first :: < Self >
        (conn).optional() ? ; Ok(result)
    }
} impl RoomToFacility
{
    pub fn get_for_room_id(& self) -> i64 { self.room_facility_id } pub fn
    get_for_room_facility_id(& self) -> i64 { self.room_id }
}
starting work on RoomTypeAvailabilityRate
join statements ".left_join(Reservation :: get_table_ref()).inner_join(Room :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: room_type_availability_rates)] pub
struct NewRoomTypeAvailabilityRate
{
    pub available_units : Option < i32 >, pub rate_amount_parameter : Option <
    f32 >, pub room_id : i64, pub date : NaiveDateTime
} #[derive(Serialize, Clone)] pub struct RoomTypeAvailabilityRateWithAll
{
    #[serde(flatten)] pub self_data : RoomTypeAvailabilityRate, pub
    reservations : Vec < Reservation >, pub room : Room,
} impl RoomTypeAvailabilityRateWithAll
{
    pub fn
    new_builder((self_data, reservations, room) :
    (RoomTypeAvailabilityRate, Option < Reservation >, Room)) -> Self
    {
        Self
        {
            self_data, reservations : if let Some(data) = reservations
            { vec! [data] } else { Vec :: new() }, room,
        }
    } pub fn
    insert_data(& mut self, (self_data, reservations, room) :
    (RoomTypeAvailabilityRate, Option < Reservation >, Room))
    { if let Some(data) = reservations { self.reservations.push(data) ; } }
} impl RoomTypeAvailabilityRate
{
    pub fn get_table_ref() -> crate :: schema :: room_type_availability_rates
    :: table
    { return crate :: schema :: room_type_availability_rates :: table ; } pub
    fn find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: room_type_availability_rates ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn
    insert(data : NewRoomTypeAvailabilityRate, conn : & mut MysqlConnection,)
    -> Result < NewRoomTypeAvailabilityRate, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: room_type_availability_rates ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: room_type_availability_rates ::
        table.filter(crate :: schema :: room_type_availability_rates ::
        id.eq(uid)).first :: < Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    RoomTypeAvailabilityRateWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec <
        RoomTypeAvailabilityRateWithAll > = Vec :: new() ; let mut last_id = 0
        ; let all_rows = crate :: schema :: room_type_availability_rates ::
        table.left_join(Reservation ::
        get_table_ref()).inner_join(Room ::
        get_table_ref()).select((RoomTypeAvailabilityRate :: as_select(),
        Option :: < Reservation > :: as_select(), Room :: as_select())).load
        :: < (RoomTypeAvailabilityRate, Option :: < Reservation >, Room) >
        (conn) ? ; for query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = RoomTypeAvailabilityRateWithAll ::
                new_builder(query_row) ; ret_data.push(data) ; last_id =
                current_id ;
            }
        } Ok(ret_data)
    } pub fn get_reservations(& self, conn : & mut MysqlConnection) -> Vec <
    Reservation >
    {
        return Reservation ::
        belonging_to(&
        self).select(Reservation ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn get_room(& self, conn : & mut MysqlConnection) -> Room
    {
        return Room ::
        find(self.room_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    } pub fn find_all_with_reservations(conn : & mut MysqlConnection) ->
    Result < Vec < RoomTypeAvailabilityRateLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomTypeAvailabilityRateLazy > = Vec :: new()
        ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        room_type_availability_rates ::
        table.left_join(Reservation ::
        get_table_ref()).select((RoomTypeAvailabilityRate :: as_select(),
        Option :: < Reservation > :: as_select())).load :: <
        (RoomTypeAvailabilityRate, Option :: < Reservation >) > (conn) ? ;
        for(self_data, reservations) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = reservations { data.push_or_set_reservations(val) ; }
            } else
            {
                let mut data = RoomTypeAvailabilityRateLazy :: init(self_data)
                ; if let Some(val) = reservations
                { data.push_or_set_reservations(val) ; } ; ret_data.push(data)
                ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_room(conn : & mut MysqlConnection) -> Result < Vec
    < RoomTypeAvailabilityRateLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomTypeAvailabilityRateLazy > = Vec :: new()
        ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        room_type_availability_rates ::
        table.inner_join(Room ::
        get_table_ref()).select((RoomTypeAvailabilityRate :: as_select(), Room
        :: as_select())).load :: < (RoomTypeAvailabilityRate, Room) > (conn) ?
        ; for(self_data, room) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ;
                data.push_or_set_room(room) ;
            } else
            {
                let mut data = RoomTypeAvailabilityRateLazy :: init(self_data)
                ; data.push_or_set_room(room) ; ; ret_data.push(data) ;
                last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct RoomTypeAvailabilityRateLazy
{
    #[serde(flatten)] pub self_data : RoomTypeAvailabilityRate, pub
    reservations : Option < Vec < Reservation > >, pub room : Option < Room >
} impl RoomTypeAvailabilityRateLazy
{
    pub fn init(self_data : RoomTypeAvailabilityRate) -> Self
    { Self { self_data, reservations : None, room : None } } pub fn
    push_or_set_reservations(& mut self, val : Reservation)
    {
        if let Some(vec) = self.reservations.as_mut() { vec.push(val) ; } else
        { self.reservations = Some(vec! [val]) ; }
    } pub fn push_or_set_room(& mut self, val : Room)
    { self.room = Some(val) ; }
}
starting work on User
join statements ".left_join(UserToRole :: get_table_ref().left_join(Role :: get_table_ref()))"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: users)] pub struct NewUser
{ pub name : String, pub password : String } #[derive(Serialize, Clone)] pub
struct UserWithAll
{ #[serde(flatten)] pub self_data : User, pub roles : Vec < Role >, } impl
UserWithAll
{
    pub fn new_builder((self_data, roles) : (User, Option < Role >)) -> Self
    {
        Self
        {
            self_data, roles : if let Some(data) = roles { vec! [data] } else
            { Vec :: new() },
        }
    } pub fn
    insert_data(& mut self, (self_data, roles) : (User, Option < Role >))
    { if let Some(data) = roles { self.roles.push(data) ; } }
} impl User
{
    pub fn get_table_ref() -> crate :: schema :: users :: table
    { return crate :: schema :: users :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: users ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewUser, conn : & mut MysqlConnection,) -> Result <
    NewUser, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: users ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: users ::
        table.filter(crate :: schema :: users :: id.eq(uid)).first :: < Self >
        (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    UserWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < UserWithAll > =
        Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        users ::
        table.left_join(UserToRole ::
        get_table_ref().left_join(Role ::
        get_table_ref())).select((User :: as_select(), Option :: < Role > ::
        as_select())).load :: < (User, Option :: < Role >) > (conn) ? ; for
        query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = UserWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_roles(& self, conn : & mut MysqlConnection) -> Vec < Role >
    {
        return UserToRole ::
        belonging_to(&
        self).inner_join(Role ::
        get_table_ref()).select(Role ::
        as_select()).load(conn).expect("error running query to fetch many to many relationship")
        ;
    } pub fn find_all_with_roles(conn : & mut MysqlConnection) -> Result < Vec
    < UserLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < UserLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: users ::
        table.left_join(UserToRole ::
        get_table_ref().left_join(Role ::
        get_table_ref())).select((User :: as_select(), Option :: < Role > ::
        as_select())).load :: < (User, Option :: < Role >) > (conn) ? ;
        for(self_data, roles) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = roles { data.push_or_set_roles(val) ; }
            } else
            {
                let mut data = UserLazy :: init(self_data) ; if let Some(val)
                = roles { data.push_or_set_roles(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct UserLazy
{
    #[serde(flatten)] pub self_data : User, pub roles : Option < Vec < Role >
    >
} impl UserLazy
{
    pub fn init(self_data : User) -> Self { Self { self_data, roles : None } }
    pub fn push_or_set_roles(& mut self, val : Role)
    {
        if let Some(vec) = self.roles.as_mut() { vec.push(val) ; } else
        { self.roles = Some(vec! [val]) ; }
    }
}
starting work on UserToRole
join statements ""
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: user_to_role)] pub struct
NewUserToRole { pub user_id : i64, pub role_id : i64 } impl UserToRole
{
    pub fn get_table_ref() -> crate :: schema :: user_to_role :: table
    { return crate :: schema :: user_to_role :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: user_to_role ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewUserToRole, conn : & mut MysqlConnection,) ->
    Result < NewUserToRole, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: user_to_role ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(role_id : i64, user_id : i64, conn : & mut MysqlConnection,)
    -> Result < Option < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: user_to_role ::
        table.filter(crate :: schema :: user_to_role ::
        user_id.eq(user_id)).filter(crate :: schema :: user_to_role ::
        role_id.eq(role_id)).first :: < Self > (conn).optional() ? ;
        Ok(result)
    }
} impl UserToRole
{
    pub fn get_for_user_id(& self) -> i64 { self.role_id } pub fn
    get_for_role_id(& self) -> i64 { self.user_id }
}
starting work on AccomodationProperty
query path guards: [Ident { ident: "role", span: #0 bytes(3790..3794) }, Dot, Ident { ident: "authority", span: #0 bytes(3795..3804) }]
join statements ".left_join(AccomodationPropertyPhoto :: get_table_ref()).left_join(Addres :: get_table_ref()).left_join(Currency :: get_table_ref()).left_join(AccomodationPropertyToFacility ::\nget_table_ref().left_join(AccomodationPropertyFacility :: get_table_ref())).left_join(Language :: get_table_ref()).left_join(Role :: get_table_ref()).left_join(Room :: get_table_ref()).left_join(AccomodationPropertyStatu :: get_table_ref()).left_join(AccomodationPropertyToType ::\nget_table_ref().left_join(AccomodationPropertyType :: get_table_ref()))"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: accomodation_property)] pub struct
NewAccomodationProperty
{
    pub version : i64, pub stars : i32, pub currency_id : Option < i64 >, pub
    number_of_rooms : i32, pub hotel_logo : Option < String >, pub address_id
    : Option < i64 >, pub checked_out : Option < bool >, pub role_id : Option
    < i64 >, pub name : String, pub status_id : Option < i64 >, pub
    preferred_language_id : Option < i64 >
} #[derive(Serialize, Clone)] pub struct AccomodationPropertyWithAll
{
    #[serde(flatten)] pub self_data : AccomodationProperty, pub facilities :
    Vec < AccomodationPropertyFacility >, pub types : Vec <
    AccomodationPropertyType >, pub accomodation_property_photos : Vec <
    AccomodationPropertyPhoto >, pub rooms : Vec < Room >, pub currency :
    Option < Currency >, pub address : Option < Addres >, pub role : Option <
    Role >, pub status : Option < AccomodationPropertyStatu >, pub
    preferred_language : Option < Language >,
} impl AccomodationPropertyWithAll
{
    pub fn
    new_builder((self_data, facilities, types, accomodation_property_photos,
    rooms, currency, address, role, status, preferred_language) :
    (AccomodationProperty, Option < AccomodationPropertyFacility >, Option <
    AccomodationPropertyType >, Option < AccomodationPropertyPhoto >, Option <
    Room >, Option < Currency >, Option < Addres >, Option < Role >, Option <
    AccomodationPropertyStatu >, Option < Language >)) -> Self
    {
        Self
        {
            self_data, facilities : if let Some(data) = facilities
            { vec! [data] } else { Vec :: new() }, types : if let Some(data) =
            types { vec! [data] } else { Vec :: new() },
            accomodation_property_photos : if let Some(data) =
            accomodation_property_photos { vec! [data] } else
            { Vec :: new() }, rooms : if let Some(data) = rooms
            { vec! [data] } else { Vec :: new() }, currency, address, role,
            status, preferred_language,
        }
    } pub fn
    insert_data(& mut self,
    (self_data, facilities, types, accomodation_property_photos, rooms,
    currency, address, role, status, preferred_language) :
    (AccomodationProperty, Option < AccomodationPropertyFacility >, Option <
    AccomodationPropertyType >, Option < AccomodationPropertyPhoto >, Option <
    Room >, Option < Currency >, Option < Addres >, Option < Role >, Option <
    AccomodationPropertyStatu >, Option < Language >))
    {
        if let Some(data) = facilities { self.facilities.push(data) ; } if let
        Some(data) = types { self.types.push(data) ; } if let Some(data) =
        accomodation_property_photos
        { self.accomodation_property_photos.push(data) ; } if let Some(data) =
        rooms { self.rooms.push(data) ; }
    }
} impl AccomodationProperty
{
    pub fn get_table_ref() -> crate :: schema :: accomodation_property ::
    table { return crate :: schema :: accomodation_property :: table ; } pub
    fn find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: accomodation_property ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn
    insert(data : NewAccomodationProperty, conn : & mut MysqlConnection,) ->
    Result < NewAccomodationProperty, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: accomodation_property ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: accomodation_property ::
        table.filter(crate :: schema :: accomodation_property ::
        id.eq(uid)).first :: < Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    AccomodationPropertyWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec <
        AccomodationPropertyWithAll > = Vec :: new() ; let mut last_id = 0 ;
        let all_rows = crate :: schema :: accomodation_property ::
        table.left_join(AccomodationPropertyPhoto ::
        get_table_ref()).left_join(Addres ::
        get_table_ref()).left_join(Currency ::
        get_table_ref()).left_join(AccomodationPropertyToFacility ::
        get_table_ref().left_join(AccomodationPropertyFacility ::
        get_table_ref())).left_join(Language ::
        get_table_ref()).left_join(Role ::
        get_table_ref()).left_join(Room ::
        get_table_ref()).left_join(AccomodationPropertyStatu ::
        get_table_ref()).left_join(AccomodationPropertyToType ::
        get_table_ref().left_join(AccomodationPropertyType ::
        get_table_ref())).select((AccomodationProperty :: as_select(), Option
        :: < AccomodationPropertyFacility > :: as_select(), Option :: <
        AccomodationPropertyType > :: as_select(), Option :: <
        AccomodationPropertyPhoto > :: as_select(), Option :: < Room > ::
        as_select(), Option :: < Currency > :: as_select(), Option :: < Addres
        > :: as_select(), Option :: < Role > :: as_select(), Option :: <
        AccomodationPropertyStatu > :: as_select(), Option :: < Language > ::
        as_select())).load :: <
        (AccomodationProperty, Option :: < AccomodationPropertyFacility >,
        Option :: < AccomodationPropertyType >, Option :: <
        AccomodationPropertyPhoto >, Option :: < Room >, Option :: < Currency
        >, Option :: < Addres >, Option :: < Role >, Option :: <
        AccomodationPropertyStatu >, Option :: < Language >) > (conn) ? ; for
        query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = AccomodationPropertyWithAll ::
                new_builder(query_row) ; ret_data.push(data) ; last_id =
                current_id ;
            }
        } Ok(ret_data)
    } pub fn get_facilities(& self, conn : & mut MysqlConnection) -> Vec <
    AccomodationPropertyFacility >
    {
        return AccomodationPropertyToFacility ::
        belonging_to(&
        self).inner_join(AccomodationPropertyFacility ::
        get_table_ref()).select(AccomodationPropertyFacility ::
        as_select()).load(conn).expect("error running query to fetch many to many relationship")
        ;
    } pub fn get_types(& self, conn : & mut MysqlConnection) -> Vec <
    AccomodationPropertyType >
    {
        return AccomodationPropertyToType ::
        belonging_to(&
        self).inner_join(AccomodationPropertyType ::
        get_table_ref()).select(AccomodationPropertyType ::
        as_select()).load(conn).expect("error running query to fetch many to many relationship")
        ;
    } pub fn
    get_accomodation_property_photos(& self, conn : & mut MysqlConnection) ->
    Vec < AccomodationPropertyPhoto >
    {
        return AccomodationPropertyPhoto ::
        belonging_to(&
        self).select(AccomodationPropertyPhoto ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn get_rooms(& self, conn : & mut MysqlConnection) -> Vec < Room >
    {
        return Room ::
        belonging_to(&
        self).select(Room ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn get_currency(& self, conn : & mut MysqlConnection) -> Option <
    Currency >
    {
        if let Some(fk_value) = self.currency_id
        {
            return Currency ::
            find(fk_value, conn).expect("could not fetch relation") ;
        } else { return None ; }
    } pub fn get_address(& self, conn : & mut MysqlConnection) -> Option <
    Addres >
    {
        if let Some(fk_value) = self.address_id
        {
            return Addres ::
            find(fk_value, conn).expect("could not fetch relation") ;
        } else { return None ; }
    } pub fn get_role(& self, conn : & mut MysqlConnection) -> Option < Role >
    {
        if let Some(fk_value) = self.role_id
        {
            return Role ::
            find(fk_value, conn).expect("could not fetch relation") ;
        } else { return None ; }
    } pub fn get_status(& self, conn : & mut MysqlConnection) -> Option <
    AccomodationPropertyStatu >
    {
        if let Some(fk_value) = self.status_id
        {
            return AccomodationPropertyStatu ::
            find(fk_value, conn).expect("could not fetch relation") ;
        } else { return None ; }
    } pub fn get_preferred_language(& self, conn : & mut MysqlConnection) ->
    Option < Language >
    {
        if let Some(fk_value) = self.preferred_language_id
        {
            return Language ::
            find(fk_value, conn).expect("could not fetch relation") ;
        } else { return None ; }
    } pub fn
    find_all_with_accomodation_property_photos(conn : & mut MysqlConnection)
    -> Result < Vec < AccomodationPropertyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AccomodationPropertyLazy > = Vec :: new() ;
        let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property ::
        table.left_join(AccomodationPropertyPhoto ::
        get_table_ref()).select((AccomodationProperty :: as_select(), Option
        :: < AccomodationPropertyPhoto > :: as_select())).load :: <
        (AccomodationProperty, Option :: < AccomodationPropertyPhoto >) >
        (conn) ? ; for(self_data, accomodation_property_photos) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = accomodation_property_photos
                { data.push_or_set_accomodation_property_photos(val) ; }
            } else
            {
                let mut data = AccomodationPropertyLazy :: init(self_data) ;
                if let Some(val) = accomodation_property_photos
                { data.push_or_set_accomodation_property_photos(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_address(conn : & mut MysqlConnection) -> Result <
    Vec < AccomodationPropertyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AccomodationPropertyLazy > = Vec :: new() ;
        let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property ::
        table.left_join(Addres ::
        get_table_ref()).select((AccomodationProperty :: as_select(), Option
        :: < Addres > :: as_select())).load :: <
        (AccomodationProperty, Option :: < Addres >) > (conn) ? ;
        for(self_data, address) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = address { data.push_or_set_address(val) ; }
            } else
            {
                let mut data = AccomodationPropertyLazy :: init(self_data) ;
                if let Some(val) = address { data.push_or_set_address(val) ; }
                ; ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_currency(conn : & mut MysqlConnection) -> Result <
    Vec < AccomodationPropertyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AccomodationPropertyLazy > = Vec :: new() ;
        let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property ::
        table.left_join(Currency ::
        get_table_ref()).select((AccomodationProperty :: as_select(), Option
        :: < Currency > :: as_select())).load :: <
        (AccomodationProperty, Option :: < Currency >) > (conn) ? ;
        for(self_data, currency) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = currency { data.push_or_set_currency(val) ; }
            } else
            {
                let mut data = AccomodationPropertyLazy :: init(self_data) ;
                if let Some(val) = currency
                { data.push_or_set_currency(val) ; } ; ret_data.push(data) ;
                last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_facilities(conn : & mut MysqlConnection) -> Result
    < Vec < AccomodationPropertyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AccomodationPropertyLazy > = Vec :: new() ;
        let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property ::
        table.left_join(AccomodationPropertyToFacility ::
        get_table_ref().left_join(AccomodationPropertyFacility ::
        get_table_ref())).select((AccomodationProperty :: as_select(), Option
        :: < AccomodationPropertyFacility > :: as_select())).load :: <
        (AccomodationProperty, Option :: < AccomodationPropertyFacility >) >
        (conn) ? ; for(self_data, facilities) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = facilities { data.push_or_set_facilities(val) ; }
            } else
            {
                let mut data = AccomodationPropertyLazy :: init(self_data) ;
                if let Some(val) = facilities
                { data.push_or_set_facilities(val) ; } ; ret_data.push(data) ;
                last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_preferred_language(conn : & mut MysqlConnection) ->
    Result < Vec < AccomodationPropertyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AccomodationPropertyLazy > = Vec :: new() ;
        let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property ::
        table.left_join(Language ::
        get_table_ref()).select((AccomodationProperty :: as_select(), Option
        :: < Language > :: as_select())).load :: <
        (AccomodationProperty, Option :: < Language >) > (conn) ? ;
        for(self_data, preferred_language) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = preferred_language
                { data.push_or_set_preferred_language(val) ; }
            } else
            {
                let mut data = AccomodationPropertyLazy :: init(self_data) ;
                if let Some(val) = preferred_language
                { data.push_or_set_preferred_language(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_role(conn : & mut MysqlConnection) -> Result < Vec
    < AccomodationPropertyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AccomodationPropertyLazy > = Vec :: new() ;
        let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property ::
        table.left_join(Role ::
        get_table_ref()).select((AccomodationProperty :: as_select(), Option
        :: < Role > :: as_select())).load :: <
        (AccomodationProperty, Option :: < Role >) > (conn) ? ;
        for(self_data, role) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = role { data.push_or_set_role(val) ; }
            } else
            {
                let mut data = AccomodationPropertyLazy :: init(self_data) ;
                if let Some(val) = role { data.push_or_set_role(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_rooms(conn : & mut MysqlConnection) -> Result < Vec
    < AccomodationPropertyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AccomodationPropertyLazy > = Vec :: new() ;
        let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property ::
        table.left_join(Room ::
        get_table_ref()).select((AccomodationProperty :: as_select(), Option
        :: < Room > :: as_select())).load :: <
        (AccomodationProperty, Option :: < Room >) > (conn) ? ;
        for(self_data, rooms) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = rooms { data.push_or_set_rooms(val) ; }
            } else
            {
                let mut data = AccomodationPropertyLazy :: init(self_data) ;
                if let Some(val) = rooms { data.push_or_set_rooms(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_status(conn : & mut MysqlConnection) -> Result <
    Vec < AccomodationPropertyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AccomodationPropertyLazy > = Vec :: new() ;
        let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property ::
        table.left_join(AccomodationPropertyStatu ::
        get_table_ref()).select((AccomodationProperty :: as_select(), Option
        :: < AccomodationPropertyStatu > :: as_select())).load :: <
        (AccomodationProperty, Option :: < AccomodationPropertyStatu >) >
        (conn) ? ; for(self_data, status) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = status { data.push_or_set_status(val) ; }
            } else
            {
                let mut data = AccomodationPropertyLazy :: init(self_data) ;
                if let Some(val) = status { data.push_or_set_status(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_types(conn : & mut MysqlConnection) -> Result < Vec
    < AccomodationPropertyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AccomodationPropertyLazy > = Vec :: new() ;
        let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property ::
        table.left_join(AccomodationPropertyToType ::
        get_table_ref().left_join(AccomodationPropertyType ::
        get_table_ref())).select((AccomodationProperty :: as_select(), Option
        :: < AccomodationPropertyType > :: as_select())).load :: <
        (AccomodationProperty, Option :: < AccomodationPropertyType >) >
        (conn) ? ; for(self_data, types) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = types { data.push_or_set_types(val) ; }
            } else
            {
                let mut data = AccomodationPropertyLazy :: init(self_data) ;
                if let Some(val) = types { data.push_or_set_types(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct AccomodationPropertyLazy
{
    #[serde(flatten)] pub self_data : AccomodationProperty, pub facilities :
    Option < Vec < AccomodationPropertyFacility > >, pub types : Option < Vec
    < AccomodationPropertyType > >, pub accomodation_property_photos : Option
    < Vec < AccomodationPropertyPhoto > >, pub rooms : Option < Vec < Room >
    >, pub currency : Option < Currency >, pub address : Option < Addres >,
    pub role : Option < Role >, pub status : Option <
    AccomodationPropertyStatu >, pub preferred_language : Option < Language >
} impl AccomodationPropertyLazy
{
    pub fn init(self_data : AccomodationProperty) -> Self
    {
        Self
        {
            self_data, facilities : None, types : None,
            accomodation_property_photos : None, rooms : None, currency :
            None, address : None, role : None, status : None,
            preferred_language : None
        }
    } pub fn
    push_or_set_accomodation_property_photos(& mut self, val :
    AccomodationPropertyPhoto)
    {
        if let Some(vec) = self.accomodation_property_photos.as_mut()
        { vec.push(val) ; } else
        { self.accomodation_property_photos = Some(vec! [val]) ; }
    } pub fn push_or_set_address(& mut self, val : Addres)
    { self.address = Some(val) ; } pub fn
    push_or_set_currency(& mut self, val : Currency)
    { self.currency = Some(val) ; } pub fn
    push_or_set_facilities(& mut self, val : AccomodationPropertyFacility)
    {
        if let Some(vec) = self.facilities.as_mut() { vec.push(val) ; } else
        { self.facilities = Some(vec! [val]) ; }
    } pub fn push_or_set_preferred_language(& mut self, val : Language)
    { self.preferred_language = Some(val) ; } pub fn
    push_or_set_role(& mut self, val : Role) { self.role = Some(val) ; } pub
    fn push_or_set_rooms(& mut self, val : Room)
    {
        if let Some(vec) = self.rooms.as_mut() { vec.push(val) ; } else
        { self.rooms = Some(vec! [val]) ; }
    } pub fn push_or_set_status(& mut self, val : AccomodationPropertyStatu)
    { self.status = Some(val) ; } pub fn
    push_or_set_types(& mut self, val : AccomodationPropertyType)
    {
        if let Some(vec) = self.types.as_mut() { vec.push(val) ; } else
        { self.types = Some(vec! [val]) ; }
    }
}
starting work on AccomodationPropertyFacility
join statements ".left_join(AccomodationPropertyToFacility :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: accomodation_property_facility)] pub
struct NewAccomodationPropertyFacility
{
    pub version : i64, pub name : String, pub hac : Option < String >, pub
    booking_extended_code : Option < String >
} #[derive(Serialize, Clone)] pub struct AccomodationPropertyFacilityWithAll
{
    #[serde(flatten)] pub self_data : AccomodationPropertyFacility, pub
    join_property : Vec < AccomodationPropertyToFacility >,
} impl AccomodationPropertyFacilityWithAll
{
    pub fn
    new_builder((self_data, join_property) :
    (AccomodationPropertyFacility, Option < AccomodationPropertyToFacility >))
    -> Self
    {
        Self
        {
            self_data, join_property : if let Some(data) = join_property
            { vec! [data] } else { Vec :: new() },
        }
    } pub fn
    insert_data(& mut self, (self_data, join_property) :
    (AccomodationPropertyFacility, Option < AccomodationPropertyToFacility >))
    { if let Some(data) = join_property { self.join_property.push(data) ; } }
} impl AccomodationPropertyFacility
{
    pub fn get_table_ref() -> crate :: schema ::
    accomodation_property_facility :: table
    { return crate :: schema :: accomodation_property_facility :: table ; }
    pub fn find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: accomodation_property_facility ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn
    insert(data : NewAccomodationPropertyFacility, conn : & mut
    MysqlConnection,) -> Result < NewAccomodationPropertyFacility, diesel ::
    result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: accomodation_property_facility ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: accomodation_property_facility ::
        table.filter(crate :: schema :: accomodation_property_facility ::
        id.eq(uid)).first :: < Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    AccomodationPropertyFacilityWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec <
        AccomodationPropertyFacilityWithAll > = Vec :: new() ; let mut last_id
        = 0 ; let all_rows = crate :: schema :: accomodation_property_facility
        ::
        table.left_join(AccomodationPropertyToFacility ::
        get_table_ref()).select((AccomodationPropertyFacility :: as_select(),
        Option :: < AccomodationPropertyToFacility > :: as_select())).load ::
        <
        (AccomodationPropertyFacility, Option :: <
        AccomodationPropertyToFacility >) > (conn) ? ; for query_row in
        all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = AccomodationPropertyFacilityWithAll ::
                new_builder(query_row) ; ret_data.push(data) ; last_id =
                current_id ;
            }
        } Ok(ret_data)
    } pub fn get_join_property(& self, conn : & mut MysqlConnection) -> Vec <
    AccomodationPropertyToFacility >
    {
        return AccomodationPropertyToFacility ::
        belonging_to(&
        self).select(AccomodationPropertyToFacility ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn find_all_with_join_property(conn : & mut MysqlConnection) ->
    Result < Vec < AccomodationPropertyFacilityLazy >, diesel :: result ::
    Error >
    {
        let mut ret_data : Vec < AccomodationPropertyFacilityLazy > = Vec ::
        new() ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property_facility ::
        table.left_join(AccomodationPropertyToFacility ::
        get_table_ref()).select((AccomodationPropertyFacility :: as_select(),
        Option :: < AccomodationPropertyToFacility > :: as_select())).load ::
        <
        (AccomodationPropertyFacility, Option :: <
        AccomodationPropertyToFacility >) > (conn) ? ;
        for(self_data, join_property) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = join_property
                {
                    data.push_or_set_join_property(val.get_for_accomodation_property_facility_id())
                    ;
                }
            } else
            {
                let mut data = AccomodationPropertyFacilityLazy ::
                init(self_data) ; if let Some(val) = join_property
                {
                    data.push_or_set_join_property(val.get_for_accomodation_property_facility_id())
                    ;
                } ; ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct AccomodationPropertyFacilityLazy
{
    #[serde(flatten)] pub self_data : AccomodationPropertyFacility, pub
    join_property : Option < Vec < i64 > >
} impl AccomodationPropertyFacilityLazy
{
    pub fn init(self_data : AccomodationPropertyFacility) -> Self
    { Self { self_data, join_property : None } } pub fn
    push_or_set_join_property(& mut self, val : i64)
    {
        if let Some(vec) = self.join_property.as_mut() { vec.push(val) ; }
        else { self.join_property = Some(vec! [val]) ; }
    }
}
starting work on AccomodationPropertyPhoto
join statements ".inner_join(AccomodationProperty :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: accomodation_property_photo)] pub
struct NewAccomodationPropertyPhoto
{
    pub version : i64, pub accomodation_property_id : i64, pub file_name :
    String
} #[derive(Serialize, Clone)] pub struct AccomodationPropertyPhotoWithAll
{
    #[serde(flatten)] pub self_data : AccomodationPropertyPhoto, pub
    accomodation_property : AccomodationProperty,
} impl AccomodationPropertyPhotoWithAll
{
    pub fn
    new_builder((self_data, accomodation_property) :
    (AccomodationPropertyPhoto, AccomodationProperty)) -> Self
    { Self { self_data, accomodation_property, } } pub fn
    insert_data(& mut self, (self_data, accomodation_property) :
    (AccomodationPropertyPhoto, AccomodationProperty)) {}
} impl AccomodationPropertyPhoto
{
    pub fn get_table_ref() -> crate :: schema :: accomodation_property_photo
    :: table
    { return crate :: schema :: accomodation_property_photo :: table ; } pub
    fn find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: accomodation_property_photo ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn
    insert(data : NewAccomodationPropertyPhoto, conn : & mut MysqlConnection,)
    -> Result < NewAccomodationPropertyPhoto, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: accomodation_property_photo ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: accomodation_property_photo ::
        table.filter(crate :: schema :: accomodation_property_photo ::
        id.eq(uid)).first :: < Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    AccomodationPropertyPhotoWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec <
        AccomodationPropertyPhotoWithAll > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: accomodation_property_photo ::
        table.inner_join(AccomodationProperty ::
        get_table_ref()).select((AccomodationPropertyPhoto :: as_select(),
        AccomodationProperty :: as_select())).load :: <
        (AccomodationPropertyPhoto, AccomodationProperty) > (conn) ? ; for
        query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = AccomodationPropertyPhotoWithAll ::
                new_builder(query_row) ; ret_data.push(data) ; last_id =
                current_id ;
            }
        } Ok(ret_data)
    } pub fn get_accomodation_property(& self, conn : & mut MysqlConnection)
    -> AccomodationProperty
    {
        return AccomodationProperty ::
        find(self.accomodation_property_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    } pub fn find_all_with_accomodation_property(conn : & mut MysqlConnection)
    -> Result < Vec < AccomodationPropertyPhotoLazy >, diesel :: result ::
    Error >
    {
        let mut ret_data : Vec < AccomodationPropertyPhotoLazy > = Vec ::
        new() ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property_photo ::
        table.inner_join(AccomodationProperty ::
        get_table_ref()).select((AccomodationPropertyPhoto :: as_select(),
        AccomodationProperty :: as_select())).load :: <
        (AccomodationPropertyPhoto, AccomodationProperty) > (conn) ? ;
        for(self_data, accomodation_property) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ;
                data.push_or_set_accomodation_property(accomodation_property)
                ;
            } else
            {
                let mut data = AccomodationPropertyPhotoLazy ::
                init(self_data) ;
                data.push_or_set_accomodation_property(accomodation_property)
                ; ; ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct AccomodationPropertyPhotoLazy
{
    #[serde(flatten)] pub self_data : AccomodationPropertyPhoto, pub
    accomodation_property : Option < AccomodationProperty >
} impl AccomodationPropertyPhotoLazy
{
    pub fn init(self_data : AccomodationPropertyPhoto) -> Self
    { Self { self_data, accomodation_property : None } } pub fn
    push_or_set_accomodation_property(& mut self, val : AccomodationProperty)
    { self.accomodation_property = Some(val) ; }
}
starting work on AccomodationPropertyStatu
join statements ".left_join(AccomodationProperty :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: accomodation_property_status)] pub
struct NewAccomodationPropertyStatu { pub version : i64, pub status : String }
#[derive(Serialize, Clone)] pub struct AccomodationPropertyStatuWithAll
{
    #[serde(flatten)] pub self_data : AccomodationPropertyStatu, pub
    accomodation_properties : Vec < AccomodationProperty >,
} impl AccomodationPropertyStatuWithAll
{
    pub fn
    new_builder((self_data, accomodation_properties) :
    (AccomodationPropertyStatu, Option < AccomodationProperty >)) -> Self
    {
        Self
        {
            self_data, accomodation_properties : if let Some(data) =
            accomodation_properties { vec! [data] } else { Vec :: new() },
        }
    } pub fn
    insert_data(& mut self, (self_data, accomodation_properties) :
    (AccomodationPropertyStatu, Option < AccomodationProperty >))
    {
        if let Some(data) = accomodation_properties
        { self.accomodation_properties.push(data) ; }
    }
} impl AccomodationPropertyStatu
{
    pub fn get_table_ref() -> crate :: schema :: accomodation_property_status
    :: table
    { return crate :: schema :: accomodation_property_status :: table ; } pub
    fn find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: accomodation_property_status ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn
    insert(data : NewAccomodationPropertyStatu, conn : & mut MysqlConnection,)
    -> Result < NewAccomodationPropertyStatu, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: accomodation_property_status ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: accomodation_property_status ::
        table.filter(crate :: schema :: accomodation_property_status ::
        id.eq(uid)).first :: < Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    AccomodationPropertyStatuWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec <
        AccomodationPropertyStatuWithAll > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: accomodation_property_status ::
        table.left_join(AccomodationProperty ::
        get_table_ref()).select((AccomodationPropertyStatu :: as_select(),
        Option :: < AccomodationProperty > :: as_select())).load :: <
        (AccomodationPropertyStatu, Option :: < AccomodationProperty >) >
        (conn) ? ; for query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = AccomodationPropertyStatuWithAll ::
                new_builder(query_row) ; ret_data.push(data) ; last_id =
                current_id ;
            }
        } Ok(ret_data)
    } pub fn get_accomodation_properties(& self, conn : & mut MysqlConnection)
    -> Vec < AccomodationProperty >
    {
        return AccomodationProperty ::
        belonging_to(&
        self).select(AccomodationProperty ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn
    find_all_with_accomodation_properties(conn : & mut MysqlConnection) ->
    Result < Vec < AccomodationPropertyStatuLazy >, diesel :: result :: Error
    >
    {
        let mut ret_data : Vec < AccomodationPropertyStatuLazy > = Vec ::
        new() ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        accomodation_property_status ::
        table.left_join(AccomodationProperty ::
        get_table_ref()).select((AccomodationPropertyStatu :: as_select(),
        Option :: < AccomodationProperty > :: as_select())).load :: <
        (AccomodationPropertyStatu, Option :: < AccomodationProperty >) >
        (conn) ? ; for(self_data, accomodation_properties) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = accomodation_properties
                { data.push_or_set_accomodation_properties(val) ; }
            } else
            {
                let mut data = AccomodationPropertyStatuLazy ::
                init(self_data) ; if let Some(val) = accomodation_properties
                { data.push_or_set_accomodation_properties(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct AccomodationPropertyStatuLazy
{
    #[serde(flatten)] pub self_data : AccomodationPropertyStatu, pub
    accomodation_properties : Option < Vec < AccomodationProperty > >
} impl AccomodationPropertyStatuLazy
{
    pub fn init(self_data : AccomodationPropertyStatu) -> Self
    { Self { self_data, accomodation_properties : None } } pub fn
    push_or_set_accomodation_properties(& mut self, val :
    AccomodationProperty)
    {
        if let Some(vec) = self.accomodation_properties.as_mut()
        { vec.push(val) ; } else
        { self.accomodation_properties = Some(vec! [val]) ; }
    }
}
starting work on AccomodationPropertyToFacility
join statements ""
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: accomodation_property_to_facility)]
pub struct NewAccomodationPropertyToFacility
{
    pub accomodation_property_id : i64, pub accomodation_property_facility_id
    : i64
} impl AccomodationPropertyToFacility
{
    pub fn get_table_ref() -> crate :: schema ::
    accomodation_property_to_facility :: table
    { return crate :: schema :: accomodation_property_to_facility :: table ; }
    pub fn find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: accomodation_property_to_facility ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn
    insert(data : NewAccomodationPropertyToFacility, conn : & mut
    MysqlConnection,) -> Result < NewAccomodationPropertyToFacility, diesel ::
    result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: accomodation_property_to_facility ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn
    find(accomodation_property_facility_id : i64, accomodation_property_id :
    i64, conn : & mut MysqlConnection,) -> Result < Option < Self >, diesel ::
    result :: Error >
    {
        let result = crate :: schema :: accomodation_property_to_facility ::
        table.filter(crate :: schema :: accomodation_property_to_facility ::
        accomodation_property_facility_id.eq(accomodation_property_facility_id)).filter(crate
        :: schema :: accomodation_property_to_facility ::
        accomodation_property_id.eq(accomodation_property_id)).first :: < Self
        > (conn).optional() ? ; Ok(result)
    }
} impl AccomodationPropertyToFacility
{
    pub fn get_for_accomodation_property_id(& self) -> i64
    { self.accomodation_property_facility_id } pub fn
    get_for_accomodation_property_facility_id(& self) -> i64
    { self.accomodation_property_id }
}
starting work on AccomodationPropertyToLanguage
join statements ""
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: accomodation_property_to_language)]
pub struct NewAccomodationPropertyToLanguage
{ pub accomodation_property_id : i64, pub language_id : i64 } impl
AccomodationPropertyToLanguage
{
    pub fn get_table_ref() -> crate :: schema ::
    accomodation_property_to_language :: table
    { return crate :: schema :: accomodation_property_to_language :: table ; }
    pub fn find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: accomodation_property_to_language ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn
    insert(data : NewAccomodationPropertyToLanguage, conn : & mut
    MysqlConnection,) -> Result < NewAccomodationPropertyToLanguage, diesel ::
    result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: accomodation_property_to_language ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn
    find(accomodation_property_id : i64, language_id : i64, conn : & mut
    MysqlConnection,) -> Result < Option < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: accomodation_property_to_language ::
        table.filter(crate :: schema :: accomodation_property_to_language ::
        accomodation_property_id.eq(accomodation_property_id)).filter(crate ::
        schema :: accomodation_property_to_language ::
        language_id.eq(language_id)).first :: < Self > (conn).optional() ? ;
        Ok(result)
    }
} impl AccomodationPropertyToLanguage
{
    pub fn get_for_accomodation_property_id(& self) -> i64
    { self.language_id } pub fn get_for_language_id(& self) -> i64
    { self.accomodation_property_id }
}
starting work on AccomodationPropertyToType
join statements ""
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: accomodation_property_to_type)] pub
struct NewAccomodationPropertyToType
{
    pub accomodation_property_id : i64, pub accomodation_property_type_id :
    i64
} impl AccomodationPropertyToType
{
    pub fn get_table_ref() -> crate :: schema :: accomodation_property_to_type
    :: table
    { return crate :: schema :: accomodation_property_to_type :: table ; } pub
    fn find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: accomodation_property_to_type ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn
    insert(data : NewAccomodationPropertyToType, conn : & mut
    MysqlConnection,) -> Result < NewAccomodationPropertyToType, diesel ::
    result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: accomodation_property_to_type ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn
    find(accomodation_property_id : i64, accomodation_property_type_id : i64,
    conn : & mut MysqlConnection,) -> Result < Option < Self >, diesel ::
    result :: Error >
    {
        let result = crate :: schema :: accomodation_property_to_type ::
        table.filter(crate :: schema :: accomodation_property_to_type ::
        accomodation_property_id.eq(accomodation_property_id)).filter(crate ::
        schema :: accomodation_property_to_type ::
        accomodation_property_type_id.eq(accomodation_property_type_id)).first
        :: < Self > (conn).optional() ? ; Ok(result)
    }
} impl AccomodationPropertyToType
{
    pub fn get_for_accomodation_property_id(& self) -> i64
    { self.accomodation_property_type_id } pub fn
    get_for_accomodation_property_type_id(& self) -> i64
    { self.accomodation_property_id }
}
starting work on AccomodationPropertyType
join statements ""
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: accomodation_property_type)] pub
struct NewAccomodationPropertyType { pub version : i64, pub type_ : String }
impl AccomodationPropertyType
{
    pub fn get_table_ref() -> crate :: schema :: accomodation_property_type ::
    table { return crate :: schema :: accomodation_property_type :: table ; }
    pub fn find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: accomodation_property_type ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn
    insert(data : NewAccomodationPropertyType, conn : & mut MysqlConnection,)
    -> Result < NewAccomodationPropertyType, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: accomodation_property_type ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: accomodation_property_type ::
        table.filter(crate :: schema :: accomodation_property_type ::
        id.eq(uid)).first :: < Self > (conn).optional() ? ; Ok(result)
    }
}
starting work on Addres
join statements ".inner_join(City :: get_table_ref()).left_join(AccomodationProperty :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: address)] pub struct NewAddres
{
    pub version : i64, pub region : Option < String >, pub telephone : Option
    < String >, pub fax : Option < String >, pub additional_emails : Option <
    String >, pub location : Option < String >, pub city : String, pub on_map
    : Option < String >, pub street : String, pub zip_code : Option < String
    >, pub email : Option < String >, pub website : Option < String >, pub
    _city_id : i64
} #[derive(Serialize, Clone)] pub struct AddresWithAll
{
    #[serde(flatten)] pub self_data : Addres, pub accomodation_properties :
    Vec < AccomodationProperty >, pub _city : City,
} impl AddresWithAll
{
    pub fn
    new_builder((self_data, accomodation_properties, _city) :
    (Addres, Option < AccomodationProperty >, City)) -> Self
    {
        Self
        {
            self_data, accomodation_properties : if let Some(data) =
            accomodation_properties { vec! [data] } else { Vec :: new() },
            _city,
        }
    } pub fn
    insert_data(& mut self, (self_data, accomodation_properties, _city) :
    (Addres, Option < AccomodationProperty >, City))
    {
        if let Some(data) = accomodation_properties
        { self.accomodation_properties.push(data) ; }
    }
} impl Addres
{
    pub fn get_table_ref() -> crate :: schema :: address :: table
    { return crate :: schema :: address :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: address ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewAddres, conn : & mut MysqlConnection,) -> Result
    < NewAddres, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: address ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: address ::
        table.filter(crate :: schema :: address :: id.eq(uid)).first :: < Self
        > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    AddresWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < AddresWithAll > =
        Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        address ::
        table.inner_join(City ::
        get_table_ref()).left_join(AccomodationProperty ::
        get_table_ref()).select((Addres :: as_select(), Option :: <
        AccomodationProperty > :: as_select(), City :: as_select())).load :: <
        (Addres, Option :: < AccomodationProperty >, City) > (conn) ? ; for
        query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = AddresWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_accomodation_properties(& self, conn : & mut MysqlConnection)
    -> Vec < AccomodationProperty >
    {
        return AccomodationProperty ::
        belonging_to(&
        self).select(AccomodationProperty ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn get__city(& self, conn : & mut MysqlConnection) -> City
    {
        return City ::
        find(self._city_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    } pub fn find_all_with__city(conn : & mut MysqlConnection) -> Result < Vec
    < AddresLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AddresLazy > = Vec :: new() ; let mut last_id
        = 0 ; let all_rows = crate :: schema :: address ::
        table.inner_join(City ::
        get_table_ref()).select((Addres :: as_select(), City ::
        as_select())).load :: < (Addres, City) > (conn) ? ;
        for(self_data, _city) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ;
                data.push_or_set__city(_city) ;
            } else
            {
                let mut data = AddresLazy :: init(self_data) ;
                data.push_or_set__city(_city) ; ; ret_data.push(data) ;
                last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn
    find_all_with_accomodation_properties(conn : & mut MysqlConnection) ->
    Result < Vec < AddresLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < AddresLazy > = Vec :: new() ; let mut last_id
        = 0 ; let all_rows = crate :: schema :: address ::
        table.left_join(AccomodationProperty ::
        get_table_ref()).select((Addres :: as_select(), Option :: <
        AccomodationProperty > :: as_select())).load :: <
        (Addres, Option :: < AccomodationProperty >) > (conn) ? ;
        for(self_data, accomodation_properties) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = accomodation_properties
                { data.push_or_set_accomodation_properties(val) ; }
            } else
            {
                let mut data = AddresLazy :: init(self_data) ; if let
                Some(val) = accomodation_properties
                { data.push_or_set_accomodation_properties(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct AddresLazy
{
    #[serde(flatten)] pub self_data : Addres, pub accomodation_properties :
    Option < Vec < AccomodationProperty > >, pub _city : Option < City >
} impl AddresLazy
{
    pub fn init(self_data : Addres) -> Self
    { Self { self_data, accomodation_properties : None, _city : None } } pub
    fn push_or_set__city(& mut self, val : City) { self._city = Some(val) ; }
    pub fn
    push_or_set_accomodation_properties(& mut self, val :
    AccomodationProperty)
    {
        if let Some(vec) = self.accomodation_properties.as_mut()
        { vec.push(val) ; } else
        { self.accomodation_properties = Some(vec! [val]) ; }
    }
}
starting work on City
join statements ".left_join(Addres :: get_table_ref()).inner_join(County :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: city)] pub struct NewCity
{
    pub cc_fips : Option < String >, pub country_iso_id : Option < String >,
    pub full_name : Option < String >, pub version : i64, pub show_city :
    bool, pub county_id : i64
} #[derive(Serialize, Clone)] pub struct CityWithAll
{
    #[serde(flatten)] pub self_data : City, pub addresses : Vec < Addres >,
    pub county : County,
} impl CityWithAll
{
    pub fn
    new_builder((self_data, addresses, county) :
    (City, Option < Addres >, County)) -> Self
    {
        Self
        {
            self_data, addresses : if let Some(data) = addresses
            { vec! [data] } else { Vec :: new() }, county,
        }
    } pub fn
    insert_data(& mut self, (self_data, addresses, county) :
    (City, Option < Addres >, County))
    { if let Some(data) = addresses { self.addresses.push(data) ; } }
} impl City
{
    pub fn get_table_ref() -> crate :: schema :: city :: table
    { return crate :: schema :: city :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: city ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewCity, conn : & mut MysqlConnection,) -> Result <
    NewCity, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: city ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: city ::
        table.filter(crate :: schema :: city :: id.eq(uid)).first :: < Self >
        (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    CityWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < CityWithAll > =
        Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        city ::
        table.left_join(Addres ::
        get_table_ref()).inner_join(County ::
        get_table_ref()).select((City :: as_select(), Option :: < Addres > ::
        as_select(), County :: as_select())).load :: <
        (City, Option :: < Addres >, County) > (conn) ? ; for query_row in
        all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = CityWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_addresses(& self, conn : & mut MysqlConnection) -> Vec <
    Addres >
    {
        return Addres ::
        belonging_to(&
        self).select(Addres ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn get_county(& self, conn : & mut MysqlConnection) -> County
    {
        return County ::
        find(self.county_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    } pub fn find_all_with_addresses(conn : & mut MysqlConnection) -> Result <
    Vec < CityLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < CityLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: city ::
        table.left_join(Addres ::
        get_table_ref()).select((City :: as_select(), Option :: < Addres > ::
        as_select())).load :: < (City, Option :: < Addres >) > (conn) ? ;
        for(self_data, addresses) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = addresses { data.push_or_set_addresses(val) ; }
            } else
            {
                let mut data = CityLazy :: init(self_data) ; if let Some(val)
                = addresses { data.push_or_set_addresses(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_county(conn : & mut MysqlConnection) -> Result <
    Vec < CityLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < CityLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: city ::
        table.inner_join(County ::
        get_table_ref()).select((City :: as_select(), County ::
        as_select())).load :: < (City, County) > (conn) ? ;
        for(self_data, county) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ;
                data.push_or_set_county(county) ;
            } else
            {
                let mut data = CityLazy :: init(self_data) ;
                data.push_or_set_county(county) ; ; ret_data.push(data) ;
                last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct CityLazy
{
    #[serde(flatten)] pub self_data : City, pub addresses : Option < Vec <
    Addres > >, pub county : Option < County >
} impl CityLazy
{
    pub fn init(self_data : City) -> Self
    { Self { self_data, addresses : None, county : None } } pub fn
    push_or_set_addresses(& mut self, val : Addres)
    {
        if let Some(vec) = self.addresses.as_mut() { vec.push(val) ; } else
        { self.addresses = Some(vec! [val]) ; }
    } pub fn push_or_set_county(& mut self, val : County)
    { self.county = Some(val) ; }
}
starting work on Country
join statements ".left_join(County :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: country)] pub struct NewCountry
{
    pub id_fips : Option < String >, pub id_iso : Option < String >, pub tld :
    Option < String >, pub country_name : Option < String >, pub version : i64
} #[derive(Serialize, Clone)] pub struct CountryWithAll
{ #[serde(flatten)] pub self_data : Country, pub counties : Vec < County >, }
impl CountryWithAll
{
    pub fn new_builder((self_data, counties) : (Country, Option < County >))
    -> Self
    {
        Self
        {
            self_data, counties : if let Some(data) = counties { vec! [data] }
            else { Vec :: new() },
        }
    } pub fn
    insert_data(& mut self, (self_data, counties) :
    (Country, Option < County >))
    { if let Some(data) = counties { self.counties.push(data) ; } }
} impl Country
{
    pub fn get_table_ref() -> crate :: schema :: country :: table
    { return crate :: schema :: country :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: country ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewCountry, conn : & mut MysqlConnection,) ->
    Result < NewCountry, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: country ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: country ::
        table.filter(crate :: schema :: country :: id.eq(uid)).first :: < Self
        > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    CountryWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < CountryWithAll > =
        Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        country ::
        table.left_join(County ::
        get_table_ref()).select((Country :: as_select(), Option :: < County >
        :: as_select())).load :: < (Country, Option :: < County >) > (conn) ?
        ; for query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = CountryWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_counties(& self, conn : & mut MysqlConnection) -> Vec <
    County >
    {
        return County ::
        belonging_to(&
        self).select(County ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn find_all_with_counties(conn : & mut MysqlConnection) -> Result <
    Vec < CountryLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < CountryLazy > = Vec :: new() ; let mut
        last_id = 0 ; let all_rows = crate :: schema :: country ::
        table.left_join(County ::
        get_table_ref()).select((Country :: as_select(), Option :: < County >
        :: as_select())).load :: < (Country, Option :: < County >) > (conn) ?
        ; for(self_data, counties) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = counties { data.push_or_set_counties(val) ; }
            } else
            {
                let mut data = CountryLazy :: init(self_data) ; if let
                Some(val) = counties { data.push_or_set_counties(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct CountryLazy
{
    #[serde(flatten)] pub self_data : Country, pub counties : Option < Vec <
    County > >
} impl CountryLazy
{
    pub fn init(self_data : Country) -> Self
    { Self { self_data, counties : None } } pub fn
    push_or_set_counties(& mut self, val : County)
    {
        if let Some(vec) = self.counties.as_mut() { vec.push(val) ; } else
        { self.counties = Some(vec! [val]) ; }
    }
}
starting work on County
join statements ".left_join(City :: get_table_ref()).inner_join(Country :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: county)] pub struct NewCounty
{ pub version : i64, pub name : String, pub country_id : i64 }
#[derive(Serialize, Clone)] pub struct CountyWithAll
{
    #[serde(flatten)] pub self_data : County, pub cities : Vec < City >, pub
    country : Country,
} impl CountyWithAll
{
    pub fn
    new_builder((self_data, cities, country) :
    (County, Option < City >, Country)) -> Self
    {
        Self
        {
            self_data, cities : if let Some(data) = cities { vec! [data] }
            else { Vec :: new() }, country,
        }
    } pub fn
    insert_data(& mut self, (self_data, cities, country) :
    (County, Option < City >, Country))
    { if let Some(data) = cities { self.cities.push(data) ; } }
} impl County
{
    pub fn get_table_ref() -> crate :: schema :: county :: table
    { return crate :: schema :: county :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: county ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewCounty, conn : & mut MysqlConnection,) -> Result
    < NewCounty, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: county ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: county ::
        table.filter(crate :: schema :: county :: id.eq(uid)).first :: < Self
        > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    CountyWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < CountyWithAll > =
        Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        county ::
        table.left_join(City ::
        get_table_ref()).inner_join(Country ::
        get_table_ref()).select((County :: as_select(), Option :: < City > ::
        as_select(), Country :: as_select())).load :: <
        (County, Option :: < City >, Country) > (conn) ? ; for query_row in
        all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = CountyWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_cities(& self, conn : & mut MysqlConnection) -> Vec < City >
    {
        return City ::
        belonging_to(&
        self).select(City ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn get_country(& self, conn : & mut MysqlConnection) -> Country
    {
        return Country ::
        find(self.country_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    } pub fn find_all_with_cities(conn : & mut MysqlConnection) -> Result <
    Vec < CountyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < CountyLazy > = Vec :: new() ; let mut last_id
        = 0 ; let all_rows = crate :: schema :: county ::
        table.left_join(City ::
        get_table_ref()).select((County :: as_select(), Option :: < City > ::
        as_select())).load :: < (County, Option :: < City >) > (conn) ? ;
        for(self_data, cities) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = cities { data.push_or_set_cities(val) ; }
            } else
            {
                let mut data = CountyLazy :: init(self_data) ; if let
                Some(val) = cities { data.push_or_set_cities(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_country(conn : & mut MysqlConnection) -> Result <
    Vec < CountyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < CountyLazy > = Vec :: new() ; let mut last_id
        = 0 ; let all_rows = crate :: schema :: county ::
        table.inner_join(Country ::
        get_table_ref()).select((County :: as_select(), Country ::
        as_select())).load :: < (County, Country) > (conn) ? ;
        for(self_data, country) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ;
                data.push_or_set_country(country) ;
            } else
            {
                let mut data = CountyLazy :: init(self_data) ;
                data.push_or_set_country(country) ; ; ret_data.push(data) ;
                last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct CountyLazy
{
    #[serde(flatten)] pub self_data : County, pub cities : Option < Vec < City
    > >, pub country : Option < Country >
} impl CountyLazy
{
    pub fn init(self_data : County) -> Self
    { Self { self_data, cities : None, country : None } } pub fn
    push_or_set_cities(& mut self, val : City)
    {
        if let Some(vec) = self.cities.as_mut() { vec.push(val) ; } else
        { self.cities = Some(vec! [val]) ; }
    } pub fn push_or_set_country(& mut self, val : Country)
    { self.country = Some(val) ; }
}
starting work on Currency
join statements ".left_join(AccomodationProperty :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: currency)] pub struct NewCurrency
{ pub version : i64, pub value : String } #[derive(Serialize, Clone)] pub
struct CurrencyWithAll
{
    #[serde(flatten)] pub self_data : Currency, pub accomodation_properties :
    Vec < AccomodationProperty >,
} impl CurrencyWithAll
{
    pub fn
    new_builder((self_data, accomodation_properties) :
    (Currency, Option < AccomodationProperty >)) -> Self
    {
        Self
        {
            self_data, accomodation_properties : if let Some(data) =
            accomodation_properties { vec! [data] } else { Vec :: new() },
        }
    } pub fn
    insert_data(& mut self, (self_data, accomodation_properties) :
    (Currency, Option < AccomodationProperty >))
    {
        if let Some(data) = accomodation_properties
        { self.accomodation_properties.push(data) ; }
    }
} impl Currency
{
    pub fn get_table_ref() -> crate :: schema :: currency :: table
    { return crate :: schema :: currency :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: currency ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewCurrency, conn : & mut MysqlConnection,) ->
    Result < NewCurrency, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: currency ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: currency ::
        table.filter(crate :: schema :: currency :: id.eq(uid)).first :: <
        Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    CurrencyWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < CurrencyWithAll >
        = Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema
        :: currency ::
        table.left_join(AccomodationProperty ::
        get_table_ref()).select((Currency :: as_select(), Option :: <
        AccomodationProperty > :: as_select())).load :: <
        (Currency, Option :: < AccomodationProperty >) > (conn) ? ; for
        query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = CurrencyWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_accomodation_properties(& self, conn : & mut MysqlConnection)
    -> Vec < AccomodationProperty >
    {
        return AccomodationProperty ::
        belonging_to(&
        self).select(AccomodationProperty ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn
    find_all_with_accomodation_properties(conn : & mut MysqlConnection) ->
    Result < Vec < CurrencyLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < CurrencyLazy > = Vec :: new() ; let mut
        last_id = 0 ; let all_rows = crate :: schema :: currency ::
        table.left_join(AccomodationProperty ::
        get_table_ref()).select((Currency :: as_select(), Option :: <
        AccomodationProperty > :: as_select())).load :: <
        (Currency, Option :: < AccomodationProperty >) > (conn) ? ;
        for(self_data, accomodation_properties) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = accomodation_properties
                { data.push_or_set_accomodation_properties(val) ; }
            } else
            {
                let mut data = CurrencyLazy :: init(self_data) ; if let
                Some(val) = accomodation_properties
                { data.push_or_set_accomodation_properties(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct CurrencyLazy
{
    #[serde(flatten)] pub self_data : Currency, pub accomodation_properties :
    Option < Vec < AccomodationProperty > >
} impl CurrencyLazy
{
    pub fn init(self_data : Currency) -> Self
    { Self { self_data, accomodation_properties : None } } pub fn
    push_or_set_accomodation_properties(& mut self, val :
    AccomodationProperty)
    {
        if let Some(vec) = self.accomodation_properties.as_mut()
        { vec.push(val) ; } else
        { self.accomodation_properties = Some(vec! [val]) ; }
    }
}
starting work on Language
join statements ".left_join(AccomodationProperty :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: language)] pub struct NewLanguage
{ pub version : i64, pub code : String, pub name : String }
#[derive(Serialize, Clone)] pub struct LanguageWithAll
{
    #[serde(flatten)] pub self_data : Language, pub accomodation_properties :
    Vec < AccomodationProperty >,
} impl LanguageWithAll
{
    pub fn
    new_builder((self_data, accomodation_properties) :
    (Language, Option < AccomodationProperty >)) -> Self
    {
        Self
        {
            self_data, accomodation_properties : if let Some(data) =
            accomodation_properties { vec! [data] } else { Vec :: new() },
        }
    } pub fn
    insert_data(& mut self, (self_data, accomodation_properties) :
    (Language, Option < AccomodationProperty >))
    {
        if let Some(data) = accomodation_properties
        { self.accomodation_properties.push(data) ; }
    }
} impl Language
{
    pub fn get_table_ref() -> crate :: schema :: language :: table
    { return crate :: schema :: language :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: language ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewLanguage, conn : & mut MysqlConnection,) ->
    Result < NewLanguage, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: language ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: language ::
        table.filter(crate :: schema :: language :: id.eq(uid)).first :: <
        Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    LanguageWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < LanguageWithAll >
        = Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema
        :: language ::
        table.left_join(AccomodationProperty ::
        get_table_ref()).select((Language :: as_select(), Option :: <
        AccomodationProperty > :: as_select())).load :: <
        (Language, Option :: < AccomodationProperty >) > (conn) ? ; for
        query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = LanguageWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_accomodation_properties(& self, conn : & mut MysqlConnection)
    -> Vec < AccomodationProperty >
    {
        return AccomodationProperty ::
        belonging_to(&
        self).select(AccomodationProperty ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn
    find_all_with_accomodation_properties(conn : & mut MysqlConnection) ->
    Result < Vec < LanguageLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < LanguageLazy > = Vec :: new() ; let mut
        last_id = 0 ; let all_rows = crate :: schema :: language ::
        table.left_join(AccomodationProperty ::
        get_table_ref()).select((Language :: as_select(), Option :: <
        AccomodationProperty > :: as_select())).load :: <
        (Language, Option :: < AccomodationProperty >) > (conn) ? ;
        for(self_data, accomodation_properties) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = accomodation_properties
                { data.push_or_set_accomodation_properties(val) ; }
            } else
            {
                let mut data = LanguageLazy :: init(self_data) ; if let
                Some(val) = accomodation_properties
                { data.push_or_set_accomodation_properties(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct LanguageLazy
{
    #[serde(flatten)] pub self_data : Language, pub accomodation_properties :
    Option < Vec < AccomodationProperty > >
} impl LanguageLazy
{
    pub fn init(self_data : Language) -> Self
    { Self { self_data, accomodation_properties : None } } pub fn
    push_or_set_accomodation_properties(& mut self, val :
    AccomodationProperty)
    {
        if let Some(vec) = self.accomodation_properties.as_mut()
        { vec.push(val) ; } else
        { self.accomodation_properties = Some(vec! [val]) ; }
    }
}
starting work on MealPlan
join statements ".left_join(Reservation :: get_table_ref()).left_join(RoomMealPlan :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: meal_plan)] pub struct NewMealPlan
{ pub name : String, pub description : Option < String > }
#[derive(Serialize, Clone)] pub struct MealPlanWithAll
{
    #[serde(flatten)] pub self_data : MealPlan, pub reservations : Vec <
    Reservation >, pub room_meal_plans : Vec < RoomMealPlan >,
} impl MealPlanWithAll
{
    pub fn
    new_builder((self_data, reservations, room_meal_plans) :
    (MealPlan, Option < Reservation >, Option < RoomMealPlan >)) -> Self
    {
        Self
        {
            self_data, reservations : if let Some(data) = reservations
            { vec! [data] } else { Vec :: new() }, room_meal_plans : if let
            Some(data) = room_meal_plans { vec! [data] } else
            { Vec :: new() },
        }
    } pub fn
    insert_data(& mut self, (self_data, reservations, room_meal_plans) :
    (MealPlan, Option < Reservation >, Option < RoomMealPlan >))
    {
        if let Some(data) = reservations { self.reservations.push(data) ; } if
        let Some(data) = room_meal_plans { self.room_meal_plans.push(data) ; }
    }
} impl MealPlan
{
    pub fn get_table_ref() -> crate :: schema :: meal_plan :: table
    { return crate :: schema :: meal_plan :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: meal_plan ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewMealPlan, conn : & mut MysqlConnection,) ->
    Result < NewMealPlan, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: meal_plan ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: meal_plan ::
        table.filter(crate :: schema :: meal_plan :: id.eq(uid)).first :: <
        Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    MealPlanWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < MealPlanWithAll >
        = Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema
        :: meal_plan ::
        table.left_join(Reservation ::
        get_table_ref()).left_join(RoomMealPlan ::
        get_table_ref()).select((MealPlan :: as_select(), Option :: <
        Reservation > :: as_select(), Option :: < RoomMealPlan > ::
        as_select())).load :: <
        (MealPlan, Option :: < Reservation >, Option :: < RoomMealPlan >) >
        (conn) ? ; for query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = MealPlanWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_reservations(& self, conn : & mut MysqlConnection) -> Vec <
    Reservation >
    {
        return Reservation ::
        belonging_to(&
        self).select(Reservation ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn get_room_meal_plans(& self, conn : & mut MysqlConnection) -> Vec
    < RoomMealPlan >
    {
        return RoomMealPlan ::
        belonging_to(&
        self).select(RoomMealPlan ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn find_all_with_reservations(conn : & mut MysqlConnection) ->
    Result < Vec < MealPlanLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < MealPlanLazy > = Vec :: new() ; let mut
        last_id = 0 ; let all_rows = crate :: schema :: meal_plan ::
        table.left_join(Reservation ::
        get_table_ref()).select((MealPlan :: as_select(), Option :: <
        Reservation > :: as_select())).load :: <
        (MealPlan, Option :: < Reservation >) > (conn) ? ;
        for(self_data, reservations) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = reservations { data.push_or_set_reservations(val) ; }
            } else
            {
                let mut data = MealPlanLazy :: init(self_data) ; if let
                Some(val) = reservations
                { data.push_or_set_reservations(val) ; } ; ret_data.push(data)
                ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_room_meal_plans(conn : & mut MysqlConnection) ->
    Result < Vec < MealPlanLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < MealPlanLazy > = Vec :: new() ; let mut
        last_id = 0 ; let all_rows = crate :: schema :: meal_plan ::
        table.left_join(RoomMealPlan ::
        get_table_ref()).select((MealPlan :: as_select(), Option :: <
        RoomMealPlan > :: as_select())).load :: <
        (MealPlan, Option :: < RoomMealPlan >) > (conn) ? ;
        for(self_data, room_meal_plans) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = room_meal_plans { data.push_or_set_room_meal_plans(val) ; }
            } else
            {
                let mut data = MealPlanLazy :: init(self_data) ; if let
                Some(val) = room_meal_plans
                { data.push_or_set_room_meal_plans(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct MealPlanLazy
{
    #[serde(flatten)] pub self_data : MealPlan, pub reservations : Option <
    Vec < Reservation > >, pub room_meal_plans : Option < Vec < RoomMealPlan >
    >
} impl MealPlanLazy
{
    pub fn init(self_data : MealPlan) -> Self
    { Self { self_data, reservations : None, room_meal_plans : None } } pub fn
    push_or_set_reservations(& mut self, val : Reservation)
    {
        if let Some(vec) = self.reservations.as_mut() { vec.push(val) ; } else
        { self.reservations = Some(vec! [val]) ; }
    } pub fn push_or_set_room_meal_plans(& mut self, val : RoomMealPlan)
    {
        if let Some(vec) = self.room_meal_plans.as_mut() { vec.push(val) ; }
        else { self.room_meal_plans = Some(vec! [val]) ; }
    }
}
starting work on PhotoTag
join statements ""
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: photo_tag)] pub struct NewPhotoTag
{ pub version : i64, pub name : String } impl PhotoTag
{
    pub fn get_table_ref() -> crate :: schema :: photo_tag :: table
    { return crate :: schema :: photo_tag :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: photo_tag ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewPhotoTag, conn : & mut MysqlConnection,) ->
    Result < NewPhotoTag, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: photo_tag ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: photo_tag ::
        table.filter(crate :: schema :: photo_tag :: id.eq(uid)).first :: <
        Self > (conn).optional() ? ; Ok(result)
    }
}
starting work on Reservation
join statements ".left_join(MealPlan :: get_table_ref()).left_join(Room :: get_table_ref()).inner_join(RoomTypeAvailabilityRate :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: reservation)] pub struct
NewReservation
{
    pub version : i64, pub room_id : Option < i64 >, pub occupancy : i32, pub
    date : NaiveDateTime, pub room_type_availability_id : i64, pub price :
    f32, pub meal_plan_id : Option < i64 >, pub status : i32
} #[derive(Serialize, Clone)] pub struct ReservationWithAll
{
    #[serde(flatten)] pub self_data : Reservation, pub room : Option < Room >,
    pub room_type_availability : RoomTypeAvailabilityRate, pub meal_plan :
    Option < MealPlan >,
} impl ReservationWithAll
{
    pub fn
    new_builder((self_data, room, room_type_availability, meal_plan) :
    (Reservation, Option < Room >, RoomTypeAvailabilityRate, Option < MealPlan
    >)) -> Self
    { Self { self_data, room, room_type_availability, meal_plan, } } pub fn
    insert_data(& mut self,
    (self_data, room, room_type_availability, meal_plan) :
    (Reservation, Option < Room >, RoomTypeAvailabilityRate, Option < MealPlan
    >)) {}
} impl Reservation
{
    pub fn get_table_ref() -> crate :: schema :: reservation :: table
    { return crate :: schema :: reservation :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: reservation ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewReservation, conn : & mut MysqlConnection,) ->
    Result < NewReservation, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: reservation ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: reservation ::
        table.filter(crate :: schema :: reservation :: id.eq(uid)).first :: <
        Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    ReservationWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < ReservationWithAll
        > = Vec :: new() ; let mut last_id = 0 ; let all_rows = crate ::
        schema :: reservation ::
        table.left_join(MealPlan ::
        get_table_ref()).left_join(Room ::
        get_table_ref()).inner_join(RoomTypeAvailabilityRate ::
        get_table_ref()).select((Reservation :: as_select(), Option :: < Room
        > :: as_select(), RoomTypeAvailabilityRate :: as_select(), Option :: <
        MealPlan > :: as_select())).load :: <
        (Reservation, Option :: < Room >, RoomTypeAvailabilityRate, Option ::
        < MealPlan >) > (conn) ? ; for query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = ReservationWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_room(& self, conn : & mut MysqlConnection) -> Option < Room >
    {
        if let Some(fk_value) = self.room_id
        {
            return Room ::
            find(fk_value, conn).expect("could not fetch relation") ;
        } else { return None ; }
    } pub fn get_room_type_availability(& self, conn : & mut MysqlConnection)
    -> RoomTypeAvailabilityRate
    {
        return RoomTypeAvailabilityRate ::
        find(self.room_type_availability_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    } pub fn get_meal_plan(& self, conn : & mut MysqlConnection) -> Option <
    MealPlan >
    {
        if let Some(fk_value) = self.meal_plan_id
        {
            return MealPlan ::
            find(fk_value, conn).expect("could not fetch relation") ;
        } else { return None ; }
    } pub fn find_all_with_meal_plan(conn : & mut MysqlConnection) -> Result <
    Vec < ReservationLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < ReservationLazy > = Vec :: new() ; let mut
        last_id = 0 ; let all_rows = crate :: schema :: reservation ::
        table.left_join(MealPlan ::
        get_table_ref()).select((Reservation :: as_select(), Option :: <
        MealPlan > :: as_select())).load :: <
        (Reservation, Option :: < MealPlan >) > (conn) ? ;
        for(self_data, meal_plan) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = meal_plan { data.push_or_set_meal_plan(val) ; }
            } else
            {
                let mut data = ReservationLazy :: init(self_data) ; if let
                Some(val) = meal_plan { data.push_or_set_meal_plan(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_room(conn : & mut MysqlConnection) -> Result < Vec
    < ReservationLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < ReservationLazy > = Vec :: new() ; let mut
        last_id = 0 ; let all_rows = crate :: schema :: reservation ::
        table.left_join(Room ::
        get_table_ref()).select((Reservation :: as_select(), Option :: < Room
        > :: as_select())).load :: < (Reservation, Option :: < Room >) >
        (conn) ? ; for(self_data, room) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = room { data.push_or_set_room(val) ; }
            } else
            {
                let mut data = ReservationLazy :: init(self_data) ; if let
                Some(val) = room { data.push_or_set_room(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn
    find_all_with_room_type_availability(conn : & mut MysqlConnection) ->
    Result < Vec < ReservationLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < ReservationLazy > = Vec :: new() ; let mut
        last_id = 0 ; let all_rows = crate :: schema :: reservation ::
        table.inner_join(RoomTypeAvailabilityRate ::
        get_table_ref()).select((Reservation :: as_select(),
        RoomTypeAvailabilityRate :: as_select())).load :: <
        (Reservation, RoomTypeAvailabilityRate) > (conn) ? ;
        for(self_data, room_type_availability) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ;
                data.push_or_set_room_type_availability(room_type_availability)
                ;
            } else
            {
                let mut data = ReservationLazy :: init(self_data) ;
                data.push_or_set_room_type_availability(room_type_availability)
                ; ; ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct ReservationLazy
{
    #[serde(flatten)] pub self_data : Reservation, pub room : Option < Room >,
    pub room_type_availability : Option < RoomTypeAvailabilityRate >, pub
    meal_plan : Option < MealPlan >
} impl ReservationLazy
{
    pub fn init(self_data : Reservation) -> Self
    {
        Self
        {
            self_data, room : None, room_type_availability : None, meal_plan :
            None
        }
    } pub fn push_or_set_meal_plan(& mut self, val : MealPlan)
    { self.meal_plan = Some(val) ; } pub fn
    push_or_set_room(& mut self, val : Room) { self.room = Some(val) ; } pub
    fn
    push_or_set_room_type_availability(& mut self, val :
    RoomTypeAvailabilityRate) { self.room_type_availability = Some(val) ; }
}
starting work on Role
join statements ".left_join(AccomodationProperty :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: role)] pub struct NewRole
{ pub version : i64, pub authority : String } #[derive(Serialize, Clone)] pub
struct RoleWithAll
{
    #[serde(flatten)] pub self_data : Role, pub accomodation_properties : Vec
    < AccomodationProperty >,
} impl RoleWithAll
{
    pub fn
    new_builder((self_data, accomodation_properties) :
    (Role, Option < AccomodationProperty >)) -> Self
    {
        Self
        {
            self_data, accomodation_properties : if let Some(data) =
            accomodation_properties { vec! [data] } else { Vec :: new() },
        }
    } pub fn
    insert_data(& mut self, (self_data, accomodation_properties) :
    (Role, Option < AccomodationProperty >))
    {
        if let Some(data) = accomodation_properties
        { self.accomodation_properties.push(data) ; }
    }
} impl Role
{
    pub fn get_table_ref() -> crate :: schema :: role :: table
    { return crate :: schema :: role :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: role ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewRole, conn : & mut MysqlConnection,) -> Result <
    NewRole, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: role ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: role ::
        table.filter(crate :: schema :: role :: id.eq(uid)).first :: < Self >
        (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    RoleWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < RoleWithAll > =
        Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        role ::
        table.left_join(AccomodationProperty ::
        get_table_ref()).select((Role :: as_select(), Option :: <
        AccomodationProperty > :: as_select())).load :: <
        (Role, Option :: < AccomodationProperty >) > (conn) ? ; for query_row
        in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = RoleWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_accomodation_properties(& self, conn : & mut MysqlConnection)
    -> Vec < AccomodationProperty >
    {
        return AccomodationProperty ::
        belonging_to(&
        self).select(AccomodationProperty ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn
    find_all_with_accomodation_properties(conn : & mut MysqlConnection) ->
    Result < Vec < RoleLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoleLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: role ::
        table.left_join(AccomodationProperty ::
        get_table_ref()).select((Role :: as_select(), Option :: <
        AccomodationProperty > :: as_select())).load :: <
        (Role, Option :: < AccomodationProperty >) > (conn) ? ;
        for(self_data, accomodation_properties) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = accomodation_properties
                { data.push_or_set_accomodation_properties(val) ; }
            } else
            {
                let mut data = RoleLazy :: init(self_data) ; if let Some(val)
                = accomodation_properties
                { data.push_or_set_accomodation_properties(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct RoleLazy
{
    #[serde(flatten)] pub self_data : Role, pub accomodation_properties :
    Option < Vec < AccomodationProperty > >
} impl RoleLazy
{
    pub fn init(self_data : Role) -> Self
    { Self { self_data, accomodation_properties : None } } pub fn
    push_or_set_accomodation_properties(& mut self, val :
    AccomodationProperty)
    {
        if let Some(vec) = self.accomodation_properties.as_mut()
        { vec.push(val) ; } else
        { self.accomodation_properties = Some(vec! [val]) ; }
    }
}
starting work on Room
query path guards: [Ident { ident: "accomodation_property", span: #0 bytes(12331..12352) }, Dot, Ident { ident: "role", span: #0 bytes(12353..12357) }, Dot, Ident { ident: "authority", span: #0 bytes(12358..12367) }]
join statements ".inner_join(AccomodationProperty :: get_table_ref()).left_join(RoomToFacility ::\nget_table_ref().left_join(RoomFacility :: get_table_ref())).inner_join(RoomPricingType :: get_table_ref()).left_join(Reservation :: get_table_ref()).left_join(RoomMealPlan :: get_table_ref()).left_join(RoomPhoto :: get_table_ref()).left_join(RoomTypeAvailabilityRate :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: room)] pub struct NewRoom
{
    pub version : i64, pub default_occupancy : i32, pub minimum_guests : i32,
    pub name : String, pub pricing_type_id : i64, pub accomodation_property_id
    : i64, pub baby_coats : i32, pub maximum_guests : i32, pub room_view :
    Option < String >, pub floor : Option < i32 >, pub description : Option <
    String >, pub size_measurement : f32, pub size_measurement_unit : String
} #[derive(Serialize, Clone)] pub struct RoomWithAll
{
    #[serde(flatten)] pub self_data : Room, pub facilities : Vec <
    RoomFacility >, pub reservations : Vec < Reservation >, pub
    room_meal_plans : Vec < RoomMealPlan >, pub room_photos : Vec < RoomPhoto
    >, pub room_type_availability_rates : Vec < RoomTypeAvailabilityRate >,
    pub pricing_type : RoomPricingType, pub accomodation_property :
    AccomodationProperty,
} impl RoomWithAll
{
    pub fn
    new_builder((self_data, facilities, reservations, room_meal_plans,
    room_photos, room_type_availability_rates, pricing_type,
    accomodation_property) :
    (Room, Option < RoomFacility >, Option < Reservation >, Option <
    RoomMealPlan >, Option < RoomPhoto >, Option < RoomTypeAvailabilityRate >,
    RoomPricingType, AccomodationProperty)) -> Self
    {
        Self
        {
            self_data, facilities : if let Some(data) = facilities
            { vec! [data] } else { Vec :: new() }, reservations : if let
            Some(data) = reservations { vec! [data] } else { Vec :: new() },
            room_meal_plans : if let Some(data) = room_meal_plans
            { vec! [data] } else { Vec :: new() }, room_photos : if let
            Some(data) = room_photos { vec! [data] } else { Vec :: new() },
            room_type_availability_rates : if let Some(data) =
            room_type_availability_rates { vec! [data] } else
            { Vec :: new() }, pricing_type, accomodation_property,
        }
    } pub fn
    insert_data(& mut self,
    (self_data, facilities, reservations, room_meal_plans, room_photos,
    room_type_availability_rates, pricing_type, accomodation_property) :
    (Room, Option < RoomFacility >, Option < Reservation >, Option <
    RoomMealPlan >, Option < RoomPhoto >, Option < RoomTypeAvailabilityRate >,
    RoomPricingType, AccomodationProperty))
    {
        if let Some(data) = facilities { self.facilities.push(data) ; } if let
        Some(data) = reservations { self.reservations.push(data) ; } if let
        Some(data) = room_meal_plans { self.room_meal_plans.push(data) ; } if
        let Some(data) = room_photos { self.room_photos.push(data) ; } if let
        Some(data) = room_type_availability_rates
        { self.room_type_availability_rates.push(data) ; }
    }
} impl Room
{
    pub fn get_table_ref() -> crate :: schema :: room :: table
    { return crate :: schema :: room :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: room ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewRoom, conn : & mut MysqlConnection,) -> Result <
    NewRoom, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: room ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: room ::
        table.filter(crate :: schema :: room :: id.eq(uid)).first :: < Self >
        (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    RoomWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < RoomWithAll > =
        Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        room ::
        table.inner_join(AccomodationProperty ::
        get_table_ref()).left_join(RoomToFacility ::
        get_table_ref().left_join(RoomFacility ::
        get_table_ref())).inner_join(RoomPricingType ::
        get_table_ref()).left_join(Reservation ::
        get_table_ref()).left_join(RoomMealPlan ::
        get_table_ref()).left_join(RoomPhoto ::
        get_table_ref()).left_join(RoomTypeAvailabilityRate ::
        get_table_ref()).select((Room :: as_select(), Option :: < RoomFacility
        > :: as_select(), Option :: < Reservation > :: as_select(), Option ::
        < RoomMealPlan > :: as_select(), Option :: < RoomPhoto > ::
        as_select(), Option :: < RoomTypeAvailabilityRate > :: as_select(),
        RoomPricingType :: as_select(), AccomodationProperty ::
        as_select())).load :: <
        (Room, Option :: < RoomFacility >, Option :: < Reservation >, Option
        :: < RoomMealPlan >, Option :: < RoomPhoto >, Option :: <
        RoomTypeAvailabilityRate >, RoomPricingType, AccomodationProperty) >
        (conn) ? ; for query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = RoomWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_facilities(& self, conn : & mut MysqlConnection) -> Vec <
    RoomFacility >
    {
        return RoomToFacility ::
        belonging_to(&
        self).inner_join(RoomFacility ::
        get_table_ref()).select(RoomFacility ::
        as_select()).load(conn).expect("error running query to fetch many to many relationship")
        ;
    } pub fn get_reservations(& self, conn : & mut MysqlConnection) -> Vec <
    Reservation >
    {
        return Reservation ::
        belonging_to(&
        self).select(Reservation ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn get_room_meal_plans(& self, conn : & mut MysqlConnection) -> Vec
    < RoomMealPlan >
    {
        return RoomMealPlan ::
        belonging_to(&
        self).select(RoomMealPlan ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn get_room_photos(& self, conn : & mut MysqlConnection) -> Vec <
    RoomPhoto >
    {
        return RoomPhoto ::
        belonging_to(&
        self).select(RoomPhoto ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn
    get_room_type_availability_rates(& self, conn : & mut MysqlConnection) ->
    Vec < RoomTypeAvailabilityRate >
    {
        return RoomTypeAvailabilityRate ::
        belonging_to(&
        self).select(RoomTypeAvailabilityRate ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn get_pricing_type(& self, conn : & mut MysqlConnection) ->
    RoomPricingType
    {
        return RoomPricingType ::
        find(self.pricing_type_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    } pub fn get_accomodation_property(& self, conn : & mut MysqlConnection)
    -> AccomodationProperty
    {
        return AccomodationProperty ::
        find(self.accomodation_property_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    } pub fn find_all_with_accomodation_property(conn : & mut MysqlConnection)
    -> Result < Vec < RoomLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: room ::
        table.inner_join(AccomodationProperty ::
        get_table_ref()).select((Room :: as_select(), AccomodationProperty ::
        as_select())).load :: < (Room, AccomodationProperty) > (conn) ? ;
        for(self_data, accomodation_property) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ;
                data.push_or_set_accomodation_property(accomodation_property)
                ;
            } else
            {
                let mut data = RoomLazy :: init(self_data) ;
                data.push_or_set_accomodation_property(accomodation_property)
                ; ; ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_facilities(conn : & mut MysqlConnection) -> Result
    < Vec < RoomLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: room ::
        table.left_join(RoomToFacility ::
        get_table_ref().left_join(RoomFacility ::
        get_table_ref())).select((Room :: as_select(), Option :: <
        RoomFacility > :: as_select())).load :: <
        (Room, Option :: < RoomFacility >) > (conn) ? ;
        for(self_data, facilities) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = facilities { data.push_or_set_facilities(val) ; }
            } else
            {
                let mut data = RoomLazy :: init(self_data) ; if let Some(val)
                = facilities { data.push_or_set_facilities(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_pricing_type(conn : & mut MysqlConnection) ->
    Result < Vec < RoomLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: room ::
        table.inner_join(RoomPricingType ::
        get_table_ref()).select((Room :: as_select(), RoomPricingType ::
        as_select())).load :: < (Room, RoomPricingType) > (conn) ? ;
        for(self_data, pricing_type) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ;
                data.push_or_set_pricing_type(pricing_type) ;
            } else
            {
                let mut data = RoomLazy :: init(self_data) ;
                data.push_or_set_pricing_type(pricing_type) ; ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_reservations(conn : & mut MysqlConnection) ->
    Result < Vec < RoomLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: room ::
        table.left_join(Reservation ::
        get_table_ref()).select((Room :: as_select(), Option :: < Reservation
        > :: as_select())).load :: < (Room, Option :: < Reservation >) >
        (conn) ? ; for(self_data, reservations) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = reservations { data.push_or_set_reservations(val) ; }
            } else
            {
                let mut data = RoomLazy :: init(self_data) ; if let Some(val)
                = reservations { data.push_or_set_reservations(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_room_meal_plans(conn : & mut MysqlConnection) ->
    Result < Vec < RoomLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: room ::
        table.left_join(RoomMealPlan ::
        get_table_ref()).select((Room :: as_select(), Option :: < RoomMealPlan
        > :: as_select())).load :: < (Room, Option :: < RoomMealPlan >) >
        (conn) ? ; for(self_data, room_meal_plans) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = room_meal_plans { data.push_or_set_room_meal_plans(val) ; }
            } else
            {
                let mut data = RoomLazy :: init(self_data) ; if let Some(val)
                = room_meal_plans { data.push_or_set_room_meal_plans(val) ; }
                ; ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_room_photos(conn : & mut MysqlConnection) -> Result
    < Vec < RoomLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: room ::
        table.left_join(RoomPhoto ::
        get_table_ref()).select((Room :: as_select(), Option :: < RoomPhoto >
        :: as_select())).load :: < (Room, Option :: < RoomPhoto >) > (conn) ?
        ; for(self_data, room_photos) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = room_photos { data.push_or_set_room_photos(val) ; }
            } else
            {
                let mut data = RoomLazy :: init(self_data) ; if let Some(val)
                = room_photos { data.push_or_set_room_photos(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn
    find_all_with_room_type_availability_rates(conn : & mut MysqlConnection)
    -> Result < Vec < RoomLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: room ::
        table.left_join(RoomTypeAvailabilityRate ::
        get_table_ref()).select((Room :: as_select(), Option :: <
        RoomTypeAvailabilityRate > :: as_select())).load :: <
        (Room, Option :: < RoomTypeAvailabilityRate >) > (conn) ? ;
        for(self_data, room_type_availability_rates) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = room_type_availability_rates
                { data.push_or_set_room_type_availability_rates(val) ; }
            } else
            {
                let mut data = RoomLazy :: init(self_data) ; if let Some(val)
                = room_type_availability_rates
                { data.push_or_set_room_type_availability_rates(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct RoomLazy
{
    #[serde(flatten)] pub self_data : Room, pub facilities : Option < Vec <
    RoomFacility > >, pub reservations : Option < Vec < Reservation > >, pub
    room_meal_plans : Option < Vec < RoomMealPlan > >, pub room_photos :
    Option < Vec < RoomPhoto > >, pub room_type_availability_rates : Option <
    Vec < RoomTypeAvailabilityRate > >, pub pricing_type : Option <
    RoomPricingType >, pub accomodation_property : Option <
    AccomodationProperty >
} impl RoomLazy
{
    pub fn init(self_data : Room) -> Self
    {
        Self
        {
            self_data, facilities : None, reservations : None, room_meal_plans
            : None, room_photos : None, room_type_availability_rates : None,
            pricing_type : None, accomodation_property : None
        }
    } pub fn
    push_or_set_accomodation_property(& mut self, val : AccomodationProperty)
    { self.accomodation_property = Some(val) ; } pub fn
    push_or_set_facilities(& mut self, val : RoomFacility)
    {
        if let Some(vec) = self.facilities.as_mut() { vec.push(val) ; } else
        { self.facilities = Some(vec! [val]) ; }
    } pub fn push_or_set_pricing_type(& mut self, val : RoomPricingType)
    { self.pricing_type = Some(val) ; } pub fn
    push_or_set_reservations(& mut self, val : Reservation)
    {
        if let Some(vec) = self.reservations.as_mut() { vec.push(val) ; } else
        { self.reservations = Some(vec! [val]) ; }
    } pub fn push_or_set_room_meal_plans(& mut self, val : RoomMealPlan)
    {
        if let Some(vec) = self.room_meal_plans.as_mut() { vec.push(val) ; }
        else { self.room_meal_plans = Some(vec! [val]) ; }
    } pub fn push_or_set_room_photos(& mut self, val : RoomPhoto)
    {
        if let Some(vec) = self.room_photos.as_mut() { vec.push(val) ; } else
        { self.room_photos = Some(vec! [val]) ; }
    } pub fn
    push_or_set_room_type_availability_rates(& mut self, val :
    RoomTypeAvailabilityRate)
    {
        if let Some(vec) = self.room_type_availability_rates.as_mut()
        { vec.push(val) ; } else
        { self.room_type_availability_rates = Some(vec! [val]) ; }
    }
}
starting work on RoomFacility
join statements ""
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: room_facilities)] pub struct
NewRoomFacility
{
    pub version : i64, pub name : String, pub rma : Option < String >, pub
    booking_extended_amenities : Option < String >
} impl RoomFacility
{
    pub fn get_table_ref() -> crate :: schema :: room_facilities :: table
    { return crate :: schema :: room_facilities :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: room_facilities ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewRoomFacility, conn : & mut MysqlConnection,) ->
    Result < NewRoomFacility, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: room_facilities ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: room_facilities ::
        table.filter(crate :: schema :: room_facilities :: id.eq(uid)).first
        :: < Self > (conn).optional() ? ; Ok(result)
    }
}
starting work on RoomMealPlan
join statements ".inner_join(MealPlan :: get_table_ref()).inner_join(Room :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: room_meal_plan)] pub struct
NewRoomMealPlan { pub room_meal_plan_id : i64, pub meal_plan_id : i64 }
#[derive(Serialize, Clone)] pub struct RoomMealPlanWithAll
{
    #[serde(flatten)] pub self_data : RoomMealPlan, pub room_meal_plan : Room,
    pub meal_plan : MealPlan,
} impl RoomMealPlanWithAll
{
    pub fn
    new_builder((self_data, room_meal_plan, meal_plan) :
    (RoomMealPlan, Room, MealPlan)) -> Self
    { Self { self_data, room_meal_plan, meal_plan, } } pub fn
    insert_data(& mut self, (self_data, room_meal_plan, meal_plan) :
    (RoomMealPlan, Room, MealPlan)) {}
} impl RoomMealPlan
{
    pub fn get_table_ref() -> crate :: schema :: room_meal_plan :: table
    { return crate :: schema :: room_meal_plan :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: room_meal_plan ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewRoomMealPlan, conn : & mut MysqlConnection,) ->
    Result < NewRoomMealPlan, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: room_meal_plan ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn
    find(meal_plan_id : i64, room_meal_plan_id : i64, conn : & mut
    MysqlConnection,) -> Result < Option < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: room_meal_plan ::
        table.filter(crate :: schema :: room_meal_plan ::
        room_meal_plan_id.eq(room_meal_plan_id)).filter(crate :: schema ::
        room_meal_plan :: meal_plan_id.eq(meal_plan_id)).first :: < Self >
        (conn).optional() ? ; Ok(result)
    } pub fn get_room_meal_plan(& self, conn : & mut MysqlConnection) -> Room
    {
        return Room ::
        find(self.room_meal_plan_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    } pub fn get_meal_plan(& self, conn : & mut MysqlConnection) -> MealPlan
    {
        return MealPlan ::
        find(self.meal_plan_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    }
} #[derive(Serialize, Clone)] pub struct RoomMealPlanLazy
{
    #[serde(flatten)] pub self_data : RoomMealPlan, pub room_meal_plan :
    Option < Room >, pub meal_plan : Option < MealPlan >
} impl RoomMealPlanLazy
{
    pub fn init(self_data : RoomMealPlan) -> Self
    { Self { self_data, room_meal_plan : None, meal_plan : None } } pub fn
    push_or_set_meal_plan(& mut self, val : MealPlan)
    { self.meal_plan = Some(val) ; } pub fn
    push_or_set_room_meal_plan(& mut self, val : Room)
    { self.room_meal_plan = Some(val) ; }
}
starting work on RoomPhoto
join statements ".inner_join(Room :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: room_photo)] pub struct NewRoomPhoto
{
    pub version : i64, pub room_id : i64, pub file_size : Option < String >,
    pub rank_sort : i32, pub file_name : String
} #[derive(Serialize, Clone)] pub struct RoomPhotoWithAll
{ #[serde(flatten)] pub self_data : RoomPhoto, pub room : Room, } impl
RoomPhotoWithAll
{
    pub fn new_builder((self_data, room) : (RoomPhoto, Room)) -> Self
    { Self { self_data, room, } } pub fn
    insert_data(& mut self, (self_data, room) : (RoomPhoto, Room)) {}
} impl RoomPhoto
{
    pub fn get_table_ref() -> crate :: schema :: room_photo :: table
    { return crate :: schema :: room_photo :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: room_photo ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewRoomPhoto, conn : & mut MysqlConnection,) ->
    Result < NewRoomPhoto, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: room_photo ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: room_photo ::
        table.filter(crate :: schema :: room_photo :: id.eq(uid)).first :: <
        Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    RoomPhotoWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < RoomPhotoWithAll >
        = Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema
        :: room_photo ::
        table.inner_join(Room ::
        get_table_ref()).select((RoomPhoto :: as_select(), Room ::
        as_select())).load :: < (RoomPhoto, Room) > (conn) ? ; for query_row
        in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = RoomPhotoWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_room(& self, conn : & mut MysqlConnection) -> Room
    {
        return Room ::
        find(self.room_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    } pub fn find_all_with_room(conn : & mut MysqlConnection) -> Result < Vec
    < RoomPhotoLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomPhotoLazy > = Vec :: new() ; let mut
        last_id = 0 ; let all_rows = crate :: schema :: room_photo ::
        table.inner_join(Room ::
        get_table_ref()).select((RoomPhoto :: as_select(), Room ::
        as_select())).load :: < (RoomPhoto, Room) > (conn) ? ;
        for(self_data, room) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ;
                data.push_or_set_room(room) ;
            } else
            {
                let mut data = RoomPhotoLazy :: init(self_data) ;
                data.push_or_set_room(room) ; ; ret_data.push(data) ; last_id
                = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct RoomPhotoLazy
{ #[serde(flatten)] pub self_data : RoomPhoto, pub room : Option < Room > }
impl RoomPhotoLazy
{
    pub fn init(self_data : RoomPhoto) -> Self
    { Self { self_data, room : None } } pub fn
    push_or_set_room(& mut self, val : Room) { self.room = Some(val) ; }
}
starting work on RoomPricingType
join statements ".left_join(Room :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: room_pricing_type)] pub struct
NewRoomPricingType { pub version : i64, pub name : String }
#[derive(Serialize, Clone)] pub struct RoomPricingTypeWithAll
{
    #[serde(flatten)] pub self_data : RoomPricingType, pub rooms : Vec < Room
    >,
} impl RoomPricingTypeWithAll
{
    pub fn
    new_builder((self_data, rooms) : (RoomPricingType, Option < Room >)) ->
    Self
    {
        Self
        {
            self_data, rooms : if let Some(data) = rooms { vec! [data] } else
            { Vec :: new() },
        }
    } pub fn
    insert_data(& mut self, (self_data, rooms) :
    (RoomPricingType, Option < Room >))
    { if let Some(data) = rooms { self.rooms.push(data) ; } }
} impl RoomPricingType
{
    pub fn get_table_ref() -> crate :: schema :: room_pricing_type :: table
    { return crate :: schema :: room_pricing_type :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: room_pricing_type ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewRoomPricingType, conn : & mut MysqlConnection,)
    -> Result < NewRoomPricingType, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: room_pricing_type ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: room_pricing_type ::
        table.filter(crate :: schema :: room_pricing_type :: id.eq(uid)).first
        :: < Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    RoomPricingTypeWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec <
        RoomPricingTypeWithAll > = Vec :: new() ; let mut last_id = 0 ; let
        all_rows = crate :: schema :: room_pricing_type ::
        table.left_join(Room ::
        get_table_ref()).select((RoomPricingType :: as_select(), Option :: <
        Room > :: as_select())).load :: <
        (RoomPricingType, Option :: < Room >) > (conn) ? ; for query_row in
        all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = RoomPricingTypeWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_rooms(& self, conn : & mut MysqlConnection) -> Vec < Room >
    {
        return Room ::
        belonging_to(&
        self).select(Room ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn find_all_with_rooms(conn : & mut MysqlConnection) -> Result < Vec
    < RoomPricingTypeLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomPricingTypeLazy > = Vec :: new() ; let
        mut last_id = 0 ; let all_rows = crate :: schema :: room_pricing_type
        ::
        table.left_join(Room ::
        get_table_ref()).select((RoomPricingType :: as_select(), Option :: <
        Room > :: as_select())).load :: <
        (RoomPricingType, Option :: < Room >) > (conn) ? ;
        for(self_data, rooms) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = rooms { data.push_or_set_rooms(val) ; }
            } else
            {
                let mut data = RoomPricingTypeLazy :: init(self_data) ; if let
                Some(val) = rooms { data.push_or_set_rooms(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct RoomPricingTypeLazy
{
    #[serde(flatten)] pub self_data : RoomPricingType, pub rooms : Option <
    Vec < Room > >
} impl RoomPricingTypeLazy
{
    pub fn init(self_data : RoomPricingType) -> Self
    { Self { self_data, rooms : None } } pub fn
    push_or_set_rooms(& mut self, val : Room)
    {
        if let Some(vec) = self.rooms.as_mut() { vec.push(val) ; } else
        { self.rooms = Some(vec! [val]) ; }
    }
}
starting work on RoomToFacility
join statements ""
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: room_to_facilities)] pub struct
NewRoomToFacility { pub room_id : i64, pub room_facility_id : i64 } impl
RoomToFacility
{
    pub fn get_table_ref() -> crate :: schema :: room_to_facilities :: table
    { return crate :: schema :: room_to_facilities :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: room_to_facilities ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewRoomToFacility, conn : & mut MysqlConnection,)
    -> Result < NewRoomToFacility, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: room_to_facilities ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn
    find(room_facility_id : i64, room_id : i64, conn : & mut MysqlConnection,)
    -> Result < Option < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: room_to_facilities ::
        table.filter(crate :: schema :: room_to_facilities ::
        room_id.eq(room_id)).filter(crate :: schema :: room_to_facilities ::
        room_facility_id.eq(room_facility_id)).first :: < Self >
        (conn).optional() ? ; Ok(result)
    }
} impl RoomToFacility
{
    pub fn get_for_room_id(& self) -> i64 { self.room_facility_id } pub fn
    get_for_room_facility_id(& self) -> i64 { self.room_id }
}
starting work on RoomTypeAvailabilityRate
join statements ".left_join(Reservation :: get_table_ref()).inner_join(Room :: get_table_ref())"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: room_type_availability_rates)] pub
struct NewRoomTypeAvailabilityRate
{
    pub available_units : Option < i32 >, pub rate_amount_parameter : Option <
    f32 >, pub room_id : i64, pub date : NaiveDateTime
} #[derive(Serialize, Clone)] pub struct RoomTypeAvailabilityRateWithAll
{
    #[serde(flatten)] pub self_data : RoomTypeAvailabilityRate, pub
    reservations : Vec < Reservation >, pub room : Room,
} impl RoomTypeAvailabilityRateWithAll
{
    pub fn
    new_builder((self_data, reservations, room) :
    (RoomTypeAvailabilityRate, Option < Reservation >, Room)) -> Self
    {
        Self
        {
            self_data, reservations : if let Some(data) = reservations
            { vec! [data] } else { Vec :: new() }, room,
        }
    } pub fn
    insert_data(& mut self, (self_data, reservations, room) :
    (RoomTypeAvailabilityRate, Option < Reservation >, Room))
    { if let Some(data) = reservations { self.reservations.push(data) ; } }
} impl RoomTypeAvailabilityRate
{
    pub fn get_table_ref() -> crate :: schema :: room_type_availability_rates
    :: table
    { return crate :: schema :: room_type_availability_rates :: table ; } pub
    fn find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: room_type_availability_rates ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn
    insert(data : NewRoomTypeAvailabilityRate, conn : & mut MysqlConnection,)
    -> Result < NewRoomTypeAvailabilityRate, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: room_type_availability_rates ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: room_type_availability_rates ::
        table.filter(crate :: schema :: room_type_availability_rates ::
        id.eq(uid)).first :: < Self > (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    RoomTypeAvailabilityRateWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec <
        RoomTypeAvailabilityRateWithAll > = Vec :: new() ; let mut last_id = 0
        ; let all_rows = crate :: schema :: room_type_availability_rates ::
        table.left_join(Reservation ::
        get_table_ref()).inner_join(Room ::
        get_table_ref()).select((RoomTypeAvailabilityRate :: as_select(),
        Option :: < Reservation > :: as_select(), Room :: as_select())).load
        :: < (RoomTypeAvailabilityRate, Option :: < Reservation >, Room) >
        (conn) ? ; for query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = RoomTypeAvailabilityRateWithAll ::
                new_builder(query_row) ; ret_data.push(data) ; last_id =
                current_id ;
            }
        } Ok(ret_data)
    } pub fn get_reservations(& self, conn : & mut MysqlConnection) -> Vec <
    Reservation >
    {
        return Reservation ::
        belonging_to(&
        self).select(Reservation ::
        as_select()).load(conn).expect("error fetching #ident from #type_name")
        ;
    } pub fn get_room(& self, conn : & mut MysqlConnection) -> Room
    {
        return Room ::
        find(self.room_id,
        conn).expect("could not fetch relation").expect("related instance does not exist")
        ;
    } pub fn find_all_with_reservations(conn : & mut MysqlConnection) ->
    Result < Vec < RoomTypeAvailabilityRateLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomTypeAvailabilityRateLazy > = Vec :: new()
        ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        room_type_availability_rates ::
        table.left_join(Reservation ::
        get_table_ref()).select((RoomTypeAvailabilityRate :: as_select(),
        Option :: < Reservation > :: as_select())).load :: <
        (RoomTypeAvailabilityRate, Option :: < Reservation >) > (conn) ? ;
        for(self_data, reservations) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = reservations { data.push_or_set_reservations(val) ; }
            } else
            {
                let mut data = RoomTypeAvailabilityRateLazy :: init(self_data)
                ; if let Some(val) = reservations
                { data.push_or_set_reservations(val) ; } ; ret_data.push(data)
                ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn find_all_with_room(conn : & mut MysqlConnection) -> Result < Vec
    < RoomTypeAvailabilityRateLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < RoomTypeAvailabilityRateLazy > = Vec :: new()
        ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        room_type_availability_rates ::
        table.inner_join(Room ::
        get_table_ref()).select((RoomTypeAvailabilityRate :: as_select(), Room
        :: as_select())).load :: < (RoomTypeAvailabilityRate, Room) > (conn) ?
        ; for(self_data, room) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ;
                data.push_or_set_room(room) ;
            } else
            {
                let mut data = RoomTypeAvailabilityRateLazy :: init(self_data)
                ; data.push_or_set_room(room) ; ; ret_data.push(data) ;
                last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct RoomTypeAvailabilityRateLazy
{
    #[serde(flatten)] pub self_data : RoomTypeAvailabilityRate, pub
    reservations : Option < Vec < Reservation > >, pub room : Option < Room >
} impl RoomTypeAvailabilityRateLazy
{
    pub fn init(self_data : RoomTypeAvailabilityRate) -> Self
    { Self { self_data, reservations : None, room : None } } pub fn
    push_or_set_reservations(& mut self, val : Reservation)
    {
        if let Some(vec) = self.reservations.as_mut() { vec.push(val) ; } else
        { self.reservations = Some(vec! [val]) ; }
    } pub fn push_or_set_room(& mut self, val : Room)
    { self.room = Some(val) ; }
}
starting work on User
join statements ".left_join(UserToRole :: get_table_ref().left_join(Role :: get_table_ref()))"
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: users)] pub struct NewUser
{ pub name : String, pub password : String } #[derive(Serialize, Clone)] pub
struct UserWithAll
{ #[serde(flatten)] pub self_data : User, pub roles : Vec < Role >, } impl
UserWithAll
{
    pub fn new_builder((self_data, roles) : (User, Option < Role >)) -> Self
    {
        Self
        {
            self_data, roles : if let Some(data) = roles { vec! [data] } else
            { Vec :: new() },
        }
    } pub fn
    insert_data(& mut self, (self_data, roles) : (User, Option < Role >))
    { if let Some(data) = roles { self.roles.push(data) ; } }
} impl User
{
    pub fn get_table_ref() -> crate :: schema :: users :: table
    { return crate :: schema :: users :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: users ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewUser, conn : & mut MysqlConnection,) -> Result <
    NewUser, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: users ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(uid : i64, conn : & mut MysqlConnection,) -> Result < Option
    < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: users ::
        table.filter(crate :: schema :: users :: id.eq(uid)).first :: < Self >
        (conn).optional() ? ; Ok(result)
    } pub fn find_all_eager(conn : & mut MysqlConnection) -> Result < Vec <
    UserWithAll >, diesel :: result :: Error >
    {
        use crate :: schema :: * ; let mut ret_data : Vec < UserWithAll > =
        Vec :: new() ; let mut last_id = 0 ; let all_rows = crate :: schema ::
        users ::
        table.left_join(UserToRole ::
        get_table_ref().left_join(Role ::
        get_table_ref())).select((User :: as_select(), Option :: < Role > ::
        as_select())).load :: < (User, Option :: < Role >) > (conn) ? ; for
        query_row in all_rows
        {
            let current_id = query_row.0.id ; if last_id == current_id
            { ret_data.last_mut().unwrap().insert_data(query_row) ; } else
            {
                let data = UserWithAll :: new_builder(query_row) ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    } pub fn get_roles(& self, conn : & mut MysqlConnection) -> Vec < Role >
    {
        return UserToRole ::
        belonging_to(&
        self).inner_join(Role ::
        get_table_ref()).select(Role ::
        as_select()).load(conn).expect("error running query to fetch many to many relationship")
        ;
    } pub fn find_all_with_roles(conn : & mut MysqlConnection) -> Result < Vec
    < UserLazy >, diesel :: result :: Error >
    {
        let mut ret_data : Vec < UserLazy > = Vec :: new() ; let mut last_id =
        0 ; let all_rows = crate :: schema :: users ::
        table.left_join(UserToRole ::
        get_table_ref().left_join(Role ::
        get_table_ref())).select((User :: as_select(), Option :: < Role > ::
        as_select())).load :: < (User, Option :: < Role >) > (conn) ? ;
        for(self_data, roles) in all_rows
        {
            let current_id = self_data.id ; if last_id == current_id
            {
                let mut data = ret_data.last_mut().unwrap() ; if let Some(val)
                = roles { data.push_or_set_roles(val) ; }
            } else
            {
                let mut data = UserLazy :: init(self_data) ; if let Some(val)
                = roles { data.push_or_set_roles(val) ; } ;
                ret_data.push(data) ; last_id = current_id ;
            }
        } Ok(ret_data)
    }
} #[derive(Serialize, Clone)] pub struct UserLazy
{
    #[serde(flatten)] pub self_data : User, pub roles : Option < Vec < Role >
    >
} impl UserLazy
{
    pub fn init(self_data : User) -> Self { Self { self_data, roles : None } }
    pub fn push_or_set_roles(& mut self, val : Role)
    {
        if let Some(vec) = self.roles.as_mut() { vec.push(val) ; } else
        { self.roles = Some(vec! [val]) ; }
    }
}
starting work on UserToRole
join statements ""
macro #[derive(diesel :: Insertable, Serialize, Deserialize)]
#[diesel(table_name = crate :: schema :: user_to_role)] pub struct
NewUserToRole { pub user_id : i64, pub role_id : i64 } impl UserToRole
{
    pub fn get_table_ref() -> crate :: schema :: user_to_role :: table
    { return crate :: schema :: user_to_role :: table ; } pub fn
    find_all(conn : & mut MysqlConnection,) -> Vec < Self >
    {
        return crate :: schema :: user_to_role ::
        table.select(Self :: as_select()).load(conn).unwrap() ;
    } pub fn insert(data : NewUserToRole, conn : & mut MysqlConnection,) ->
    Result < NewUserToRole, diesel :: result :: Error >
    {
        diesel ::
        insert_into(crate :: schema :: user_to_role ::
        table).values(& data).execute(conn) ? ; Ok(data)
    } pub fn find(role_id : i64, user_id : i64, conn : & mut MysqlConnection,)
    -> Result < Option < Self >, diesel :: result :: Error >
    {
        let result = crate :: schema :: user_to_role ::
        table.filter(crate :: schema :: user_to_role ::
        user_id.eq(user_id)).filter(crate :: schema :: user_to_role ::
        role_id.eq(role_id)).first :: < Self > (conn).optional() ? ;
        Ok(result)
    }
} impl UserToRole
{
    pub fn get_for_user_id(& self) -> i64 { self.role_id } pub fn
    get_for_role_id(& self) -> i64 { self.user_id }
}
url requested: /client/promotions
Hi from response
url requested: /client/search/Hot
Hi from response
url requested: /client/search/Hot
Hi from response
url requested: /client/search/Hot
Hi from response
